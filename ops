{"version":1,"ops":[{"type":3,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1472038737,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0MjAzNDAzMg==","github-url":"https://github.com/DFHack/dfhack/issues/985#issuecomment-242034032"},"message":"I was thinking about something like this. Though my idea was something along the lines of \"transactional core\"+ \"fast viewer\". The reasoning is that most of \"viewing\" needs to be up to date and can have dropped packets etc. but the input needs to be exact. This ties very well into TCP vs UDP choice.\n\nSimilarly here: if we use JSON for everything it will probably hit performance issues. IMHO we should use the protocol buffers or better yet (with new df and dfhack using new visual studio) move to even faster (de)serialization.\n\nThat being said as with all things relating to performance it would need to be profiled. But that would only be visible later (when e.g. somebody builds a client that shows history of a selected units clan and dfhack sends MASSIVE JSON as a response). \nAlso i'm not an expert in all json things and imo it's a very bad format good only for html era javascript nonsense :)\n\nAs for other parts: it would be awesome. I think it already mirrors a lot of what mifki done with dfremote (https://github.com/mifki/dfremote).","files":null},{"type":3,"author":{"id":"f7b5a7930d0e1264ae1e4a774b03a7e78c2b7858"},"timestamp":1472041670,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0MjA0NDc3NA==","github-url":"https://github.com/DFHack/dfhack/issues/985#issuecomment-242044774"},"message":"Good to have an issue to centralise discussion then!\n\nI think we had roughly the same idea actually - I was thinking that the fast viewer (ie `remotefortressreader`) is a separate plugin, and this _only_ sends commands.  If you want to get any data back (except command status), use a different plugin!  And yes, same idea that viewing can be out-of sync or stuttery without serious issues, but commands _must_ be transmitted at high quality.\n\nThe advantage of JSON is that everything can speak json.  Websites, scripts, native apps, etc...  And if it's _only_ sending commands and returning the status of each, I think the total volume would be low enough to be OK.  But I haven't written anything like this before, hence the discussion!\n\nThis is mostly a subset of Mifki's dfremote functions, with (I think) some extra handling to enable multiplayer control (stateless/transactional/etc).  I'd love to see more of his stuff merged into mainline DFHack though, especially TwbT!","files":null},{"type":5,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1472043351,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDc2NTkyODE0NQ=="},"added":["idea"],"removed":[]},{"type":3,"author":{"id":"21111596d814722152a65a59652f76459a4dee15"},"timestamp":1472174483,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0MjU5NDAyNg==","github-url":"https://github.com/DFHack/dfhack/issues/985#issuecomment-242594026"},"message":"Just to poke my head where it doesn't belong as I probably wouldn't use this directly and am not too familiar with it.\n\nIf I were to make a suggestion then I would very strongly consider one of the common RPC libraries such as thrift or grpc that supports many languages, are reasonably standard and are arguably high performance remoting libraries.   Thrift has lua bindings while grpc does not afaik.   Now there are pros and cons to this but it would in theory provide a decent standard to work with multiple languages which would be a reasonable for most devs and minimizes work the network layer work.  \n\nI've used thrift with C#, python and node.js and it basically worked as needed but its not perfect.  node.js was used with react/angular for realtime html dashboards.  REST with json isn't a bad but you have more overhead than with a binary protocol in theory.  If I were doing a realtime website, I'd consider doing a mid-tier node.js server or something rather than trying to use df directly as the webserver but I suppose it would depend on what was available.  This isn't sexy to install though for end users though.\n\nHaving said that these libraries are not panaceas and can easily be used in bad ways but could also make it easier to implement.  I suppose you can just do a rest api with json but I think i really does depend on what the goal is.","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1472176580,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0MjYwMTg3OA==","github-url":"https://github.com/DFHack/dfhack/issues/985#issuecomment-242601878"},"message":"For what it's worth, I experimented with a remote DF server (like dfterm3) a while back, and found that a binary protocol for screen data worked best. I used JSON for almost everything else (well, I planned to), and routed everything through a server instead of having DF interface with clients directly (which made things simpler on the DF side, and provided better feedback when DF crashed).\n\nJSON does have a couple advantages - it's widely-supported, like PE mentioned, and we already have a JSON library included in DFHack. I doubt that the (size) overhead of JSON over other formats would be that significant compared to screen data. Obviously, massive responses are something to be avoided, but I'm not convinced that anything large enough to cause serious performance issues when serialized to JSON wouldn't also be slow when serialized to other formats.","files":null},{"type":3,"author":{"id":"f7b5a7930d0e1264ae1e4a774b03a7e78c2b7858"},"timestamp":1472200697,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0MjY2Nzc1Nw==","github-url":"https://github.com/DFHack/dfhack/issues/985#issuecomment-242667757"},"message":"The idea here is that all the high-volume stuff - screen data, item positions, whatever - would be handled by other tools.\n\nFor passing around _commands only_, I think JSON is the best option.  The payloads are small - a very high estimate is two packets per second, each a few KB at most (coordinates, action names, context object of some kind...).  \n\nAnd IMO making it as easy as possible to write middleware for this is really important, since that's where client or server features come from, whereas this proposal is basically for a standardised protocol.","files":null},{"type":3,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1473229466,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0NTE4NjY5MA==","github-url":"https://github.com/DFHack/dfhack/issues/985#issuecomment-245186690"},"message":"So how would it look like? E.g. i want to have a \"pause\" thingy. Would there be - pause/unpause commands or set/get commands? How would the json look (how much metadata?)\nAlso about the transactional part - do we have json with \"Start transaction\" or is it just a feature that e.g. build 10 beds at coords [pos1,pos2,...] either queues them up all or fails (and does nothing).","files":null},{"type":3,"author":{"id":"f7b5a7930d0e1264ae1e4a774b03a7e78c2b7858"},"timestamp":1473390352,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0NTgwNjI2Nw==","github-url":"https://github.com/DFHack/dfhack/issues/985#issuecomment-245806267"},"message":"The schema isn't finished, but it should have a couple of properties:\n1. Idempotent where possible - instead of \"toggle pause\" or \"increase zoom\", \"set $state to $value\".\n2. No implicit state, ever.  So a command object starts with the mode (main menu, dwarfmode, adventure, legends, worldgen, etc), the the context (eg dwarfmode menu, dwarfmode mainscreen).  Includes absolute cursor coordinates for each step where that's required, and so on.  This would be a PITA to write by hand, but it's designed for machine validation.\n3. Transactional, meaning that each command object (IE json object received) either succeeds or fails entirely.  The size of each command is basically up to clients.  \n   \n   _As an example, suppose I'm queuing armor production (and want a full set or nothing).  Client A is single-player, and values fast feedback - so each piece is sent as a separate command.  Client B is multiplayer, and batches the armor pieces into a single command - meaning that displayed state is speculative or delayed, but avoiding partial results.  Fortunately, our server doesn't know or care about the client - just executing a command object, and returning a success or failure diagnostic._\n\nI'd like to build a toy prototype before finalising the schema too, which is likely to take a while.","files":null}]}