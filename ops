{"version":1,"ops":[{"type":5,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1555427359,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDIyODAwMTc4NDk="},"added":["idea"],"removed":[]},{"type":5,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1555427367,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDIyODAwMTgzMTY="},"added":["structures"],"removed":[]},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1582989875,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5Mjk1NTk2Nw==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-592955967"},"message":"Moving from issue #DFHack/df-structures/372:\n\nAnother attribute that would be useful to export would be \"is-union\", especially if paired with a \"discriminant\". If is-union's parameter can be changed to be the name of the field that determines which of the versions of the overlapping data that's applicable when known, and e.g. \"nil\" (or retain \"true\") when not known, it would be sufficient to export it as is.\nIf is-union has to have a boolean value, the introduction of a new attribute for that purpose would be useful.\n\nIf this is paired with the convention of ensuring each overlaying variant of the union data is a single field (by collecting groups in structs, etc.), and defining the overlaying fields in the same order as the discriminant field does, it would allow scripts (e.g. gui/gm-editor) to determine and use the appropriate variant when the discriminant is a simple 0-based enum/number field.\n\nOne technical way to export the attributes of interest would be to define them as explicit attributes connected to the appropriate fields of types, so e.g. df.incident.T_unk_v42_1 would get the attribute \"is-union\" with value=\"subtype\" (and a number of structs with only padding would be defined to pad out the union to align the variant with the discriminant).","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1582989875,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6MzU0OTY5MzU4"},"target":"df80aacaa0fd293a5fa962d73acb0a48f52e082486a07784855c3fbb2c62b0e5","message":"Moving from issue DFHack/df-structures#372:\n\nAnother attribute that would be useful to export would be \"is-union\", especially if paired with a \"discriminant\". If is-union's parameter can be changed to be the name of the field that determines which of the versions of the overlapping data that's applicable when known, and e.g. \"nil\" (or retain \"true\") when not known, it would be sufficient to export it as is.\nIf is-union has to have a boolean value, the introduction of a new attribute for that purpose would be useful.\n\nIf this is paired with the convention of ensuring each overlaying variant of the union data is a single field (by collecting groups in structs, etc.), and defining the overlaying fields in the same order as the discriminant field does, it would allow scripts (e.g. gui/gm-editor) to determine and use the appropriate variant when the discriminant is a simple 0-based enum/number field.\n\nOne technical way to export the attributes of interest would be to define them as explicit attributes connected to the appropriate fields of types, so e.g. df.incident.T_unk_v42_1 would get the attribute \"is-union\" with value=\"subtype\" (and a number of structs with only padding would be defined to pad out the union to align the variant with the discriminant).","files":null},{"type":3,"author":{"id":"8aef4ad26d2b4762925d15b4fa91036a55d7d34c"},"timestamp":1582993976,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5Mjk2MzIzNw==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-592963237"},"message":"Here is an union example (one I know because I use it in Dwarf Therapist): `unit_preference`\nhttps://github.com/DFHack/df-structures/blob/0.47.03-beta1/df.units.xml#L2097-L2123\n\n`type` tells you how to read the anonymous union. It is a nice enum starting at 0 with consecutive values, but the mapping is not one to one. `LikeMaterial` does not use the union, `LikeCreature` and `HateCreature` both use `creature_id`, `LikeFood` and `LikeItem` both use `item_type`, `LikePlant` and `LikeTree` both use `plant_id`.\n\nWould you duplicate fields (with the same type and the same `ref-target`) to match the enum? There would also be the need for a special field meaning \"not initialized\" (like `std::monostate` is for `std::variant`).","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1582997326,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5Mjk3MDQxNw==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-592970417"},"message":"If I remember correctly XML schema can actually handle this, because it's got a union construct, but it's not used for DFHack, and some high level languages also supports it (high level assembly doesn't, of course).\nAnyway, I'd work around the problem with:\n´´´\n\u003ccompound is-union='true'\u003e\n            \u003cint16_t name='not_used' comment=\"LikeMaterial\"/\u003e\n            \u003cint16_t name='like_creature_id' ref-target='creature_raw' comment=\"LikeCreature\"/\u003e\n            \u003cenum base-type='int16_t' name=\"food_item_type\" type-name='item_type' comment=\"LikeFood\"/\u003e\n            \u003cint16_t name='hate_creature_id' ref-target='creature_raw' comment=\"HateCreature\"/\u003e\n            \u003cenum base-type='int16_t' name=\"like_item_type\" type-name='item_type' comment=\"LikeItem\"/\u003e\n            \u003cint16_t name='plant_id' ref-target='plant_raw' comment=\"LikePlant\"/\u003e\n            \u003cint16_t name='tree_plant_id' ref-target='plant_raw' comment=\"LikeTree\"/\u003e\n            \u003cint16_t name='color_id' ref-target='descriptor_color' comment=\"LikeColor\"/\u003e\n            \u003cint16_t name='shape_id' ref-target='descriptor_shape' comment=\"LikeShape\"/\u003e\n            \u003cint32_t name='poetic_form_id' ref-target='poetic_form' comment=\"LikePoeticForm\"/\u003e\n            \u003cint32_t name='musical_form_id' ref-target='musical_form' comment=\"LikeMusicalForm\"/\u003e\n            \u003cint32_t name='dance_form_id' ref-target='dance_form' comment=\"LikeDanceForm\"/\u003e\n        \u003c/compound\u003e\n´´´\nwith the purpose of the comments being to help to keep the fields are in the correct order.\nIt would be even better if the comment could be replaced by an attribute that could be applied multiple times, so the plant_id line would get e.g. ´´´discriminant-value='LikePlant' discriminant-value=\"LikeTree\"´´´, in which case the LikeMaterial variant wouldn't need any dummy field at all.\nThis would remove the need to keep the elements in order and the discriminant type to be well behaved, but would introduce a mapping table.","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1582997326,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6MzU0OTc1NzEx"},"target":"ca7f9e9c8a5dd280eca5f43571347e4cdc107ac27629850b4b58d1b217cdc1ce","message":"If I remember correctly XML schema can actually handle this, because it's got a union construct, but it's not used for DFHack, and some high level languages also supports it (high level assembly doesn't, of course).\nAnyway, I'd work around the problem with:\n´´´\n\u003ccompound is-union='true'\u003e\n            \u003cint16_t name='not_used' comment=\"LikeMaterial\"/\u003e\n            \u003cint16_t name='like_creature_id' ref-target='creature_raw' comment=\"LikeCreature\"/\u003e\n            \u003cenum base-type='int16_t' name=\"food_item_type\" type-name='item_type' comment=\"LikeFood\"/\u003e\n            \u003cint16_t name='hate_creature_id' ref-target='creature_raw' comment=\"HateCreature\"/\u003e\n            \u003cenum base-type='int16_t' name=\"like_item_type\" type-name='item_type' comment=\"LikeItem\"/\u003e\n            \u003cint16_t name='plant_id' ref-target='plant_raw' comment=\"LikePlant\"/\u003e\n            \u003cint16_t name='tree_plant_id' ref-target='plant_raw' comment=\"LikeTree\"/\u003e\n            \u003cint16_t name='color_id' ref-target='descriptor_color' comment=\"LikeColor\"/\u003e\n            \u003cint16_t name='shape_id' ref-target='descriptor_shape' comment=\"LikeShape\"/\u003e\n            \u003cint32_t name='poetic_form_id' ref-target='poetic_form' comment=\"LikePoeticForm\"/\u003e\n            \u003cint32_t name='musical_form_id' ref-target='musical_form' comment=\"LikeMusicalForm\"/\u003e\n            \u003cint32_t name='dance_form_id' ref-target='dance_form' comment=\"LikeDanceForm\"/\u003e\n        \u003c/compound\u003e\n´´´\nwith the purpose of the comments being to help to keep the fields are in the correct order.\nIt would be even better if the comment could be replaced by an attribute that could be applied multiple times, so the plant_id line would get e.g. ´´´discriminant-value='LikePlant' discriminant-value=\"LikeTree\"´´´, in which case the LikeMaterial variant wouldn't need any dummy field at all.\nThis would remove the need to keep the elements in order and the discriminant type to be well behaved, but would introduce a mapping table.\n\nEdit: However, if you wanted a real bitch of a case, go for thoughts, with its implicit unions within the subthought and severity fields...","files":null},{"type":3,"author":{"id":"fefd87bd170e69ba989c5932b26d53a6f30e8666"},"timestamp":1583001333,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5Mjk3OTk1OQ==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-592979959"},"message":"`check-structures-sanity` supports tagged unions via two formats:\n\n1. a field with a name ending in `data` that's a union of pointers and a field with the same prefix and `type` as the suffix that's an enum with names the same as the union field names.\n2. the same two fields with any names, union immediately followed by enum.","files":null},{"type":3,"author":{"id":"fefd87bd170e69ba989c5932b26d53a6f30e8666"},"timestamp":1583003778,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5Mjk4MzkxMg==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-592983912"},"message":"with a30678cee330425acd37f29a43007d05dcb62d0b there is now a `union_identity` type. I've also added an enum for the flags that pointer fields have in their `count` value.\n\nto handle the case described by @PatrikLundell, I could remove the \"of pointers\" requirement for check-structures-sanity and add support for this style of tagged unions in lua","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1583004121,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5Mjk4NTA3OA==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-592985078"},"message":"Hm, if I understand BenLubar correctly (two comments up, as a second post arrived while I typed) then df.world.xml should change incident.unk_v42_1 to\ne.g. incident.supplemental_data and incident.subtype to incident.supplemental_type (the extra and match up the enum element names with the union field names (Combat - Combat, Crime - Crime, etc.)?\n\nAnd df.entities.xml:entity_event should either switch place with entity_event_type, or it cannot match the second pattern, as the actual entity_event field isn't immediately followed by an entity_event_type field?\nIt would certainly provide a lot more flexibility if the type definition were the key, rather than whatever order DF has happened to place them in.","files":null},{"type":3,"author":{"id":"fefd87bd170e69ba989c5932b26d53a6f30e8666"},"timestamp":1583007951,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5Mjk5MDg5MQ==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-592990891"},"message":"the second pattern is only used if the first pattern doesn't apply (either the union doesn't end in \"data\" or there's no field that ends in \"type\")","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1583008138,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5Mjk5MTIzNA==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-592991234"},"message":"Ah, I see.","files":null},{"type":3,"author":{"id":"fefd87bd170e69ba989c5932b26d53a6f30e8666"},"timestamp":1583023926,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5MzAyNDQ1Mg==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-593024452"},"message":"just added rule 2 to help with a lot of the structures that follow the foo, foo_target format:\n\n1. if the field name ends in \"data\" and there is a field with the same\n   prefix ending in \"type\", the field ending in \"type\" is the tag.\n2. if the field name ends in \"_target\" and the previous field has the\n   same prefix and no suffix, the previous field is the tag.\n3. if the field is not the last field in the structure, the next field\n   is the tag.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1583082074,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU5MzExNjIxNA==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-593116214"},"message":"I don't know if it's related to this change or to the change to 0.47.04, but I suddenly have a save I've used (and not changed) for mapping blow up when trying to use gui/gm-editor to examine a df.specific_ref object, and since it contains two unions, suspicions arise...\nThe specific_ref pointer itself looks reasonable, so I'd expect it's trying to process a pointer inside that causes the problem (in the past I've gotten the impression that \"pointer\" values of -1 are bad news).","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1583082074,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6MzU1MDM5ODI3"},"target":"44627f8d644d215546e687c0df86809a0175fad38587be83685bb8027dfb7f4d","message":"I don't know if it's related to this change or to the change to 0.47.04, but I suddenly have a save I've used (and not changed) for mapping blow up when trying to use gui/gm-editor to examine a df.specific_ref object, and since it contains two unions, suspicions arise...\nThe specific_ref pointer itself looks reasonable, so I'd expect it's trying to process a pointer inside that causes the problem (in the past I've gotten the impression that \"pointer\" values of -1 are bad news).\nEdit:\nI tried the first and the last out of 20 or so items in the world that have something in their specific_refs vector, and both blew up (the original one was referenced from the first unit processed that had an item with elements in its specific_refs vector, and may or may not be the same item as one of the others, but I suspect all of them now cause a crash when accessed.","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1583498960,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6MzU2Mjc0OTg5"},"target":"44627f8d644d215546e687c0df86809a0175fad38587be83685bb8027dfb7f4d","message":"I don't know if it's related to this change or to the change to 0.47.04, but I suddenly have a save I've used (and not changed) for mapping blow up when trying to use gui/gm-editor to examine a df.specific_ref object, and since it contains two unions, suspicions arise...\nThe specific_ref pointer itself looks reasonable, so I'd expect it's trying to process a pointer inside that causes the problem (in the past I've gotten the impression that \"pointer\" values of -1 are bad news).\nEdit:\nI tried the first and the last out of 20 or so items in the world that have something in their specific_refs vector, and both blew up (the original one was referenced from the first unit processed that had an item with elements in its specific_refs vector, and may or may not be the same item as one of the others, but I suspect all of them now cause a crash when accessed.\n\nEdit2: It now does not blow up, so something has changed. However, I suspect things don't quite work the way it's intended with gui/gm-editor:\nThe item examined is an item in a job with a specific ref. Looking at the specific ref, it shows a type of 2= JOB, which is good, and a data field of type specific_ref.T_data, which is also good. However, when descending into data, I see two fields, \"object\", and \"UNIT_ITEM_WRESTLE\", and I suspect there should be only one, and that \"UNIT_ITEM_WRESTLE\" ought to be visible only when type = UNIT_ITEM_WRESTLE. It seems the logic that hides the inappropriate variants handled the pointers, but couldn't make sense of the UNIT_ITEM_WRESTLE variant.\nRegardless, the functionality is a significant improvement over suppressing everything.","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1586312411,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYxMDcxNDQzOA==","github-url":"https://github.com/DFHack/dfhack/issues/1436#issuecomment-610714438"},"message":"Exposing ref-target to Lua seems to be harder than I expected - [field_reference](https://github.com/DFHack/dfhack/blob/0.47.04-beta1/library/LuaTypes.cpp#L532) seems to be the place to do it, but it's ultimately just using a metatable specific to the *type* of the field, not accounting for any field-specific data (which everything in the newly-added struct_field_info_extra seems to be).","files":null}]}