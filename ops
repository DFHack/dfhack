{"version":1,"ops":[{"type":5,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1506260242,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDEyNjI2NjM4MTQ="},"added":["64-bit"],"removed":[]},{"type":5,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1506260242,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDEyNjI2NjM4MTU="},"added":["crash/hang"],"removed":[]},{"type":5,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1506260242,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDEyNjI2NjM4MTY="},"added":["lua"],"removed":[]},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1506268930,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMTcxOTQ2Mg==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-331719462"},"message":"I don't think this is fixable. It's basically just a wrapper around the delete operator, and that'll crash if you try to use it on something that wasn't heap-allocated. I don't think the Lua API can distinguish between objects that can be freed with delete and ones that can't.\n\nI'm pretty sure a destructor that's \"not available\" refers to one we haven't found, e.g. for a virtual class, rather than a destructor that'll crash if it's called.","files":null},{"type":3,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1506270388,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMTcyMTE2MA==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-331721160"},"message":"Then docs must be updated. Also strange that 32bit does not crash.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1506272894,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMTcyNDExOQ==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-331724119"},"message":"I don't know anything about the internals, so my questions might be rather uninformed, but I would have thought the destructor called should be for the stl-vector that the XML representation identifies, rather than the naked pointer visible for it through things like gui/gm-editor and printall (and assuming the stl-vectors set up by DF itself are actually allocated from the heap, the destructor crashes 64 bit for heap allocated data as well)?","files":null},{"type":3,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1506275226,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMTcyNjYxNA==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-331726614"},"message":"I don't think there is a way to differentiate pointer from reference. However i've not look very deeply at this.","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1506367931,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMTk4NzczMg==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-331987732"},"message":"\u003e I don't think there is a way to differentiate pointer from reference.\n\nI'm pretty sure there is not.\n\nSomething like `df.unit:new().social_activities:delete()` is always invalid, as it would be in C++. There's no way for DFHack to tell whether you're deleting something that you actually allocated with new() or something else (and in this case, both unit and unit.social_activities are on the heap). Granted, that doesn't *guarantee* that DF will crash if you try it, and it *seems* to not crash reliably on 32-bit Windows or OS X, but that doesn't make it any less undefined.\n\nAlso, calling the vector's destructor in this case is unsafe, even if you could do it without crashing, because you would still be able to access the vector in an inconsistent state after its destructor was called. Use erase() or resize() if you want to remove elements from a vector.","files":null},{"type":5,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1506367938,"metadata":{"github-id":"MDE0OlVubGFiZWxlZEV2ZW50MTI2NDM5MDQ3Mg=="},"added":[],"removed":["64-bit"]},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1506430460,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMjE4ODY3Nw==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-332188677"},"message":"This: `dfhack.println (unit.social_activities._type)` prints \"vector\u003cint32_t\u003e\", which indicates the script \"understands\" the element is a vector object. So, what does `unit.social_activities:delete()` do? It seems this extracts the pointer to the vector part of the object from within the std::vector object header (or whatever you'd call the part of the object embedded in the \"struct\") and sends it for standard naked pointer destruction, which doesn't make much sense. The most logical thing would be to call the destructor for a vector object (which, as far as I understand, returns the array part pointed to to the heap, as well as destroying any objects in the vector (if applicable). It ought to set the pointer inside the header part of the object itself to null in order not to leave any dangling references, but it can't really destroy the header itself in any meaningful way, although it could be marked as being illegal to use).\n\nThe above does not mean there have to be a reasonably feasible way to distinguish between a reference inside an object header and a naked pointer at the point the meaning of :delete() is evaluated, though.\n\nEdit: If calling the vector's destructor is considered too dangerous (which I can understand), doing nothing (and returning false) is a better option than blindly trying to destroy a naked pointer that isn't, and it would be consistent with the documentation.","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1506434642,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMjIwODY3Nw==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-332208677"},"message":"\u003e It seems this extracts the pointer to the vector part of the object from within the std::vector object header (or whatever you'd call the part of the object embedded in the \"struct\") and sends it for standard naked pointer destruction, which doesn't make much sense.\n\nIn C++, it's the same as\n```c++\ndf::unit *u = new df::unit;\ndelete \u0026(u-\u003esocial_activities);\n```\nThis is not safe.\n\nThe Lua API docs talk about \"refs\" some. Essentially, every Lua wrapper around a C++ object is a pointer plus some type information. It's impossible to tell whether this pointer points to a vector allocated with `df.new('ptr-vector')` or a vector that's part of a dynamically-allocated object. `delete()` uses C++'s `delete` operator under the hood, which only works with things directly allocated with `new`, not things contained in another object allocated with `new`.\n\nDestroying a vector that's part of another object is only safe when also destroying that object. Even if you called the vector's destructor and set the pointer in the Lua ref to null, the containing object would still exist and contain a vector in an inconsistent state.\n\n\u003e it would be consistent with the documentation\n\nThe documentation for `delete()` says:\n\n\u003e Destroys the object with the C++ delete operator. If destructor is not available, returns false.\n\n\"not available\" means that we know there's a destructor but we don't know how to call it (for example, a destructor in a subclass of a virtual class that we haven't located). We definitely know how to call the destructor for a vector, so a vector's destructor is always available, even if calling it would crash. Also, sometimes, calling delete() on a vector *does* make sense (e.g. `df.new('ptr-vector'):delete()`), and is safe.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1506437895,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMjIyNjQ3NA==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-332226474"},"message":"Well, trying to use a C delete on an element of a struct by passing the address of the element when the element is found not to be a naked pointer is definitely not safe, and I doubt it makes sense in any context. It would be slightly less unsafe if it did something like \"delete(u-\u003esocial_activities.vector_data_pointer)\" (which I thought it did).\nThe part about \"destructor not found\" in the documentation makes no sense if the C++ delete operation is called regardless of what the destructor is (unless it's a really obscure way of saying it won't actually crash if you do it on discrete non objects such as integers and floats).\n\"delete\" calls the destructor of the object the pointer points to if there is a destructor for it, according to a web search, but delete is not the destructor for a for an std::vector (I assume that would be ~std::vector). \"delete\" is the destructor for a pointer to an std::vector.\n\nI agree \"df.new('ptr-vector'):delete())\" is safe, but I disagree that it makes sense, as it doesn't achieve anything useful, and you're not calling it on the vector but on a pointer to the vector.","files":null},{"type":3,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1506489301,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMjQxMTAxNQ==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-332411015"},"message":"I feel like this went off the rails somewhat. I.e. @PatrikLundell you have difference of opinion of how it should work and slight misunderstanding what is possible.\n\nMy original feeling is that it only needs documentation change so it would clarify what \"destructor is not available\" means.\n\nAlso df.new('ptr-vector'):delete() achieve something useful. It allocates and deletes a vector. Of course this is itself useless but imagine that there is some computation happening in between. E.g. `local a=df.new('ptr-vector); some_df_vmethod_needing_vector(a); a:delete()` (there is a more error safe way of doing this but the argument is the same as it does the same under the hood).","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1506497625,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDMzMjQzNTU2Ng==","github-url":"https://github.com/DFHack/dfhack/issues/1170#issuecomment-332435566"},"message":"If the documentation said it invokes the C++ delete operation and should be used only on things created with new (no mentioning of destructors or indications of being safe to call in any other circumstances) it would describe how I think it is intended to work and the scope where it is safe to use it (provided my understanding of it isn't too off).","files":null},{"type":5,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1513459066,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDEzOTA4Nzg5MTQ="},"added":["documentation"],"removed":[]},{"type":5,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1513459068,"metadata":{"github-id":"MDE0OlVubGFiZWxlZEV2ZW50MTM5MDg3ODkyMA=="},"added":[],"removed":["crash/hang"]},{"type":4,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1513459076,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MTM5MDg3ODk0Nw=="},"status":2}]}