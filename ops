{"version":1,"ops":[{"type":1,"author":{"id":"21111596d814722152a65a59652f76459a4dee15"},"timestamp":1471842912,"metadata":{"github-id":"MDU6SXNzdWUxNzIzNzExNDU=","github-url":"https://github.com/DFHack/dfhack/issues/984","origin":"github"},"title":"Add additional VTable support for Win64","message":"This should be a pull request but I cannot get my fork straightened out and I'm not sure my solution will 100% cover the issue but does fix my immediate issues.\n\nBasically, TWBT will not load due to render vtable patching not working correctly.  This is due to different registers being used in x64 architecture which breaks the special cases in vmethod lookup so additional cases need to be added.\n\nI will at least proposed this patch for VTableInterpose.cpp:\n\n``` diff\n library/VTableInterpose.cpp | 19 +++++++++++++++++--\n 1 file changed, 17 insertions(+), 2 deletions(-)\n\ndiff --git a/library/VTableInterpose.cpp b/library/VTableInterpose.cpp\nindex c547800..27d1772 100644\n--- a/library/VTableInterpose.cpp\n+++ b/library/VTableInterpose.cpp\n@@ -124,6 +124,9 @@ bool DFHack::is_vmethod_pointer_(void *pptr)\n     case 0x20FF018BU: // mov eax, [ecx]; jmp [eax]\n     case 0x60FF018BU: // mov eax, [ecx]; jmp [eax+0x??]\n     case 0xA0FF018BU: // mov eax, [ecx]; jmp [eax+0x????????]\n+#if _M_X64\n+    case 0XFF018B48U: // mov rax, qword ptr[rcx]; jmp qword ptr[rax]\n+#endif\n         return true;\n     default:\n         return false;\n@@ -143,9 +146,21 @@ int DFHack::vmethod_pointer_to_idx_(void *pptr)\n         return ((int8_t)pval[1])/sizeof(void*);\n     case 0xA0FF018BU: // mov eax, [ecx]; jmp [eax+0x????????]\n         return ((int32_t)pval[1])/sizeof(void*);\n-    default:\n-        return -1;\n+#if _M_X64\n+    case 0XFF018B48U:\n+        switch (((uint8_t *)pval)[4])\n+        {\n+        case 0x20:  // mov rax, qword ptr[rcx]; jmp qword ptr[rax]\n+            return 0;\n+        case 0x60:  // mov rax, qword ptr[rcx]; jmp qword ptr[rax+0x??]\n+            return (((uint8_t *)pval)[5]) / sizeof(void*);\n+        case 0xA0:  // mov rax, qword ptr[rcx]; jmp qword ptr[rax+0x????????]\n+            return *(int32_t*)((int8_t *)pval+5) / sizeof(void*);\n+        }\n+        break;\n+#endif\n     }\n+    return -1;\n }\n\n void* DFHack::method_pointer_to_addr_(void *pptr)\n```\n\nAlso seems like there are issues with rebase pointers on Win64\n\n``` diff\n library/include/VersionInfo.h | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/library/include/VersionInfo.h b/library/include/VersionInfo.h\nindex b3d6c83..f6a4dc4 100644\n--- a/library/include/VersionInfo.h\n+++ b/library/include/VersionInfo.h\n@@ -53,7 +53,7 @@ namespace DFHack\n         std::map \u003cstd::string, uintptr_t\u003e Addresses;\n         std::map \u003cstd::string, uintptr_t\u003e VTables;\n         uintptr_t base;\n-        uintptr_t rebase_delta;\n+        intptr_t rebase_delta;\n         std::string version;\n         OSType OS;\n     public:\n@@ -76,7 +76,7 @@ namespace DFHack\n         };\n\n         uintptr_t getBase () const { return base; };\n-        int getRebaseDelta() const { return rebase_delta; }\n+        intptr_t getRebaseDelta() const { return rebase_delta; }\n         void setBase (const uintptr_t _base) { base = _base; };\n         void rebaseTo(const uintptr_t new_base)\n         {\n```","files":null}]}