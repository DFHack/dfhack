{"version":1,"ops":[{"type":3,"author":{"id":"88b79c31fdfd52952dafcabb16168259734368cc"},"timestamp":1464463751,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIyMjMyNTY1OA==","github-url":"https://github.com/DFHack/dfhack/issues/935#issuecomment-222325658"},"message":"I think the idea was to have the wrapper as simple as possible: no private, no const, no other crud that means compiles to nothing. E.g. all vmethod takes pointers instead of references, because that is what the decompiled code looks like. The original code probably had references there.","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1464480551,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIyMjMzNTQ4MQ==","github-url":"https://github.com/DFHack/dfhack/issues/935#issuecomment-222335481"},"message":"A couple things:\n- According to @quietust, some vmethods _should_ be const but aren't marked as such currently, so they can't be used with const objects in C++ easily\n- Some custom methods are already const, for good reasons, and I don't want to make them non-const to wrap them\n\nI think my main concern was that const-ness of objects wouldn't be tracked by the Lua API and could crash, but now that I think about that, the only way for that to happen would be to call a non-const method on a read-only object, which can already happen.\n\nAnyway, this actually only requires 1 return_type and 2 function_wrapper specializations (since non-methods can't have the `const` qualifier).","files":null},{"type":4,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1464639796,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50Njc2MzIzMjc2"},"status":2},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1464639819,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIyMjU1MDI0Mg==","github-url":"https://github.com/DFHack/dfhack/issues/935#issuecomment-222550242"},"message":"Const vmethod support should go in df-structures.","files":null}]}