{"version":1,"ops":[{"type":1,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1581784733,"metadata":{"github-id":"MDU6SXNzdWU1NjU3NzUxMjY=","github-url":"https://github.com/DFHack/dfhack/issues/1498","origin":"github"},"title":"Fixed digfort script from forums","message":"From Abadrausar: http://www.bay12forums.com/smf/index.php?topic=164123.msg8091067#msg8091067\n\n```ruby\n# designate an area based on a '.csv' plan\n=begin\n\ndigfort\n=======\nA script to designate an area for digging according to a plan in csv format.\n\nThis script, inspired from quickfort, can designate an area for digging.\nYour plan should be stored in a .csv file like this::\n\n    # this is a comment\n    d;d;u;d;d;skip this tile;d\n    d;d;d;i\n\nAvailable tile shapes are named after the 'dig' menu shortcuts:\n``d`` for dig, ``u`` for upstairs, ``j`` downstairs, ``i`` updown,\n``h`` channel, ``r`` upward ramp, ``x`` remove designation.\nUnrecognized characters are ignored (eg the 'skip this tile' in the sample).\n\nEmpty lines and data after a ``#`` are ignored as comments.\nTo skip a row in your design, use a single ``;``.\n\nOne comment in the file may contain the phrase ``start(3,5)``. It is interpreted\nas an offset for the pattern: instead of starting at the cursor, it will start\n3 tiles left and 5 tiles up from the cursor.\n\nadditionally a comment can have a \u003c for a rise in z level and a \u003e for drop in z.\n\nThe script takes the plan filename, starting from the root df folder (where\n``Dwarf Fortress.exe`` is found).\n\n=end\n\nfname = $script_args[0].to_s\nmap = df.world.map\nXsentinel = map.x_count - 1\nYsentinel = map.y_count - 1\nXstamp = false\nYstamp = false\nif not $script_args[0] then\n    puts \"  Usage: digfort \u003cplan filename\u003e\"\n    throw :script_finished\nend\nif not fname[-4..-1] == \".csv\" then\n    puts \"  The plan file must be in .csv format.\"\n    throw :script_finished\nend\nif not File.file?(fname) then\n    puts \"  The specified file does not exist.\"\n    throw :script_finished\nend\n\nplanfile = File.read(fname)\n\nif df.cursor.x == -30000\n    puts \"place the game cursor to the top-left corner of the design and retry\"\n    throw :script_finished\nend\n\noffset = [0, 0]\ntiles = []\nmax_x = 0\nmax_y = 0\ny = 0\nplanfile.each_line { |l|\n    if l =~ /#.*start\\s*\\(\\s*(-?\\d+)\\s*[,;]\\s*(-?\\d+)/\n        raise \"Error: multiple start() comments\" if offset != [0, 0]\n        offset = [$1.to_i, $2.to_i]\n    end\n    if l.chomp == '#\u003c'\n        l = '\u003c'\n        y = 0\n    end\n\n    if l.chomp == '#\u003e'\n        l = '\u003e'\n        y = 0\n    end\n\n    l = l.chomp.sub(/#.*/, '')\n    next if l == ''\n    x = 0\n    tiles \u003c\u003c l.split(/[;,]/).map { |t|\n        t = t.strip\n        if x \u003c Xsentinel then x += 1 else x = Xsentinel ; Xstamp = true end\n        max_x = x if x \u003e max_x and not t.empty?\n        (t[0] == '\"') ? t[1..-2] : t\n    }\n    if y \u003c Ysentinel then y += 1 else y = Ysentinel ; Xstamp = true end\n\n}\n \nx = df.cursor.x - offset[0]\ny = df.cursor.y - offset[1]\nz = df.cursor.z\nstarty = y - 1\n\nif x \u003c 0 or y \u003c 0 or x+max_x \u003e= map.x_count or y+max_y \u003e= map.y_count\n    max_x = max_x + x + 1\n    max_y = max_y + y + 1\n    raise \"Position would designate outside map limits. Selected limits are from (#{x+1}, #{y+1}) to (#{max_x},#{max_y})\"\nend\n\ntiles.each { |line|\n    next if line.empty? or line == ['']\n    line.each { |tile|\n        if tile.empty?\n            if x \u003c Xsentinel then x += 1 else x = Xsentinel ; Xstamp = true end\n            next\n        end\n        t = df.map_tile_at(x, y, z)\n        s = t.shape_basic\n        case tile\n        when 'd'; t.dig(:Default) if s == :Wall\n        when 'u'; t.dig(:UpStair) if s == :Wall\n        when 'j'; t.dig(:DownStair) if s == :Wall or s == :Floor\n        when 'i'; t.dig(:UpDownStair) if s == :Wall\n        when 'h'; t.dig(:Channel) if s == :Wall or s == :Floor\n        when 'r'; t.dig(:Ramp) if s == :Wall\n        when 'x'; t.dig(:No)\n        when '\u003c'; y=starty; z += 1\n        when '\u003e'; y=starty; z -= 1\n        end\n        if x \u003c Xsentinel then x += 1 else x = Xsentinel ; Xstamp = true end\n    }\n    x = df.cursor.x - offset[0]\n    if y \u003c Ysentinel then y += 1 else y = Ysentinel ; Ystamp = true end\n}\n\nif Xstamp or Ystamp then\n  puts 'Warning: ' + (Xstamp ? 'the columns': '') + (Xstamp and Ystamp ? ' and ': '') + (Ystamp ? 'the rows' : '') + ' of the blueprint that overflow the designable area of the Dwarf Fortress embark have been ignored'\n  puts '         if your blueprint X or Y dimension is close to that of the embark map, this warning is probably a false positive due to faulty logic in this script'\nend\n\nputs '  done'\n```","files":null}]}