{"version":1,"ops":[{"type":5,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1468018323,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDcxNzYwODIzMQ=="},"added":["bug"],"removed":[]},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1468018367,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTQ5MTM3MA==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-231491370"},"message":"Maybe try http://dffd.bay12games.com/?","files":null},{"type":3,"author":{"id":"8324d9ed133176471a45b3d4b19bb8c3391cb983"},"timestamp":1468018911,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTQ5MjU4MQ==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-231492581"},"message":"Totally forgot dffd existed.  [Here](http://dffd.bay12games.com/file.php?id=12242)'s the save.  The poor bastard, \"Shorast Delertoral, Weretapir,\" is locked in the only inhabited room on z-level 126.","files":null},{"type":5,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1468525887,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDcyMzQ5ODg0MQ=="},"added":["has save"],"removed":[]},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1579796038,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzc1MjE5OA==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-577752198"},"message":"Here's a fixed version. The damned git refuses to cooperate (as usual) claiming there's a conflict between the unmodified library/Console-windows.cpp file between the just created github branch and local one created slightly earlier from a develop that git claimed was up to date, and also dislikes that the auto modified depends/jsoncpp-sub is different.\n\n```\n// cursecheck plugin\n//\n// check single tile or whole map/world for cursed creatures by checking if a valid curse date (!=-1) is set\n// if a cursor is active only the selected tile will be observed\n// without cursor the whole map will be checked\n// by default cursed creatures will be only counted\n//\n// the tool was intended to help finding vampires but it will also list necromancers, werebeasts and zombies\n//\n// Options:\n//   detail  - print full name, date of birth, date of curse (vamp might use fake identity, though)\n//             show if the creature is active or dead, missing, ghostly (ghost vampires should not exist in 34.05)\n//             identify type of curse (works fine for vanilla ghosts, vamps, werebeasts, zombies and necromancers)\n//   nick    - set nickname to type of curse(does not always show up ingame, some vamps don't like nicknames)\n//   all     - don't ignore dead and inactive creatures (former ghosts, dead necromancers, ...)\n//   verbose - acts like detail but also lists all curse tags (if you want to know it all).\n\n#include \u003ciostream\u003e\n#include \u003ciomanip\u003e\n#include \u003cclimits\u003e\n#include \u003cvector\u003e\n#include \u003cstring\u003e\n#include \u003csstream\u003e\n#include \u003cctime\u003e\n#include \u003ccstdio\u003e\nusing namespace std;\n\n#include \"Core.h\"\n#include \"Console.h\"\n#include \"PluginManager.h\"\n#include \"modules/Units.h\"\n#include \u003cmodules/Translation.h\u003e\n#include \"modules/Gui.h\"\n#include \"MiscUtils.h\"\n\n#include \"df/unit.h\"\n#include \"df/unit_soul.h\"\n#include \"df/unit_syndrome.h\"\n#include \"df/historical_entity.h\"\n#include \"df/historical_figure.h\"\n#include \"df/historical_figure_info.h\"\n#include \"df/identity.h\"\n#include \"df/language_name.h\"\n#include \"df/syndrome.h\"\n#include \"df/world.h\"\n#include \"df/world_raws.h\"\n#include \"df/incident.h\"\n\nusing std::vector;\nusing std::string;\nusing namespace DFHack;\nusing namespace df::enums;\n\nDFHACK_PLUGIN(\"cursecheck\");\nREQUIRE_GLOBAL(world);\nREQUIRE_GLOBAL(cursor);\n\nenum class curses : int8_t {\n    None,\n    Unknown,\n    Ghost,\n    Zombie,\n    Necromancer,\n    Werebeast,\n    Vampire\n};\n\nstd::vector\u003cstring\u003e curse_names = \n{\"none\",\n\"unknown\",\n\"ghost\",\n\"zombie\",\n\"necromancer\",\n\"werebeast\",\n\"vampire\"\n};\n\ncommand_result cursecheck (color_ostream \u0026out, vector \u003cstring\u003e \u0026 parameters);\n\nDFhackCExport command_result plugin_init ( color_ostream \u0026out, std::vector \u003cPluginCommand\u003e \u0026commands)\n{\n    commands.push_back(PluginCommand(\"cursecheck\",\n        \"Check for cursed creatures (undead, necromancers...)\",\n        cursecheck, false ));\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_shutdown ( color_ostream \u0026out )\n{\n    return CR_OK;\n}\n\ncurses determineCurse(df::unit * unit)\n{\n    curses cursetype = curses::None;\n    \n    if (unit-\u003ecurse_year != -1)\n    {\n        cursetype = curses::Unknown;\n    }\n\n    // ghosts: ghostly, duh\n    // as of DF 34.05 and higher vampire ghosts and the like should not be possible\n    // if they get reintroduced later it will become necessary to watch 'ghostly' seperately\n    if(unit-\u003eflags3.bits.ghostly)\n        cursetype = curses::Ghost;\n\n    // zombies: undead or hate life (according to ag), not bloodsuckers\n    if( (unit-\u003ecurse.add_tags1.bits.OPPOSED_TO_LIFE || unit-\u003ecurse.add_tags1.bits.NOT_LIVING)\n        \u0026\u0026 !unit-\u003ecurse.add_tags1.bits.BLOODSUCKER )\n        cursetype = curses::Zombie;\n\n    // necromancers: alive, don't eat, don't drink, don't age\n    if(!unit-\u003ecurse.add_tags1.bits.NOT_LIVING\n        \u0026\u0026 unit-\u003ecurse.add_tags1.bits.NO_EAT\n        \u0026\u0026 unit-\u003ecurse.add_tags1.bits.NO_DRINK\n        \u0026\u0026 unit-\u003ecurse.add_tags2.bits.NO_AGING\n        )\n        cursetype = curses::Necromancer;\n\n    // werecreatures: subjected to a were syndrome. The curse effects are active only when\n    // in were form.\n    for (size_t i = 0; i \u003c unit-\u003esyndromes.active.size(); i++)\n    {\n        for (size_t k = 0; k \u003c world-\u003eraws.syndromes.all[unit-\u003esyndromes.active[i]-\u003etype]-\u003esyn_class.size(); k++)\n        {\n            if (strcmp (world-\u003eraws.syndromes.all[unit-\u003esyndromes.active[i]-\u003etype]-\u003esyn_class[k]-\u003ec_str(), \"WERECURSE\") == 0)\n            {\n                cursetype = curses::Werebeast;\n                break;\n            }\n        }\n    }\n\n    // vampires: bloodsucker (obvious enough)\n    if(unit-\u003ecurse.add_tags1.bits.BLOODSUCKER)\n        cursetype = curses::Vampire;\n\n    return cursetype;\n}\n\ncommand_result cursecheck (color_ostream \u0026out, vector \u003cstring\u003e \u0026 parameters)\n{\n    CoreSuspender suspend;\n    int32_t cursorX, cursorY, cursorZ;\n    Gui::getCursorCoords(cursorX,cursorY,cursorZ);\n\n    bool giveDetails = false;\n    bool giveNick = false;\n    bool ignoreDead = true;\n    bool verbose = false;\n    size_t cursecount = 0;\n\n    for(size_t i = 0; i \u003c parameters.size();i++)\n    {\n        if(parameters[i] == \"help\" || parameters[i] == \"?\")\n        {\n            out.print(  \"  Search for cursed creatures (ghosts, vampires, necromancers, zombies, werebeasts).\\n\"\n                        \"  With map cursor active only the current tile will be checked.\\n\"\n                        \"  Without an in-game cursor the whole map/world will be scanned.\\n\"\n                        \"  By default cursed creatures are only counted to make it more interesting.\\n\"\n                        \"  By default dead and passive creatures (aka really dead) are ignored.\\n\"\n                        \"Options:\\n\"\n                        \"  detail  - show details (name and age shown ingame might differ)\\n\"\n                        \"  nick    - try to set cursetype as nickname (does not always work)\\n\"\n                        \"  all     - include dead and passive creatures\\n\"\n                        \"  verbose - show all curse tags (if you really want to know it all)\\n\"\n                        );\n            return CR_OK;\n        }\n        if(parameters[i] == \"detail\")\n            giveDetails = true;\n        if(parameters[i] == \"nick\")\n            giveNick = true;\n        if(parameters[i] == \"all\")\n            ignoreDead = false;\n        if(parameters[i] == \"verbose\")\n        {\n            // verbose makes no sense without enabling details\n            giveDetails = true;\n            verbose = true;\n        }\n    }\n\n    // check whole map if no cursor is active\n    bool checkWholeMap = false;\n    if(cursorX == -30000)\n    {\n        out.print(\"No cursor; will check all units on the map.\\n\");\n        checkWholeMap = true;\n    }\n\n    for(size_t i = 0; i \u003c world-\u003eunits.all.size(); i++)\n    {\n        df::unit * unit = world-\u003eunits.all[i];\n\n        // filter out all \"living\" units that are currently removed from play\n        // don't spam all completely dead creatures if not explicitly wanted\n        if((!Units::isActive(unit) \u0026\u0026 !Units::isKilled(unit)) || (Units::isKilled(unit) \u0026\u0026 ignoreDead))\n        {\n            continue;\n        }\n\n        // bail out if we have a map cursor and creature is not at that specific position\n        if ( !checkWholeMap \u0026\u0026 (unit-\u003epos.x != cursorX || unit-\u003epos.y != cursorY || unit-\u003epos.z != cursorZ) )\n        {\n            continue;\n        }\n\n        curses cursetype = determineCurse(unit);\n\n        if (cursetype != curses::None)\n        {\n             cursecount++;\n\n            if(giveNick)\n            {\n                Units::setNickname(unit, curse_names[static_cast\u003csize_t\u003e(cursetype)].c_str()); //\"CURSED\");\n            }\n\n            if (giveDetails)\n            {\n                if (unit-\u003ename.has_name)\n                {\n                    string firstname = unit-\u003ename.first_name;\n                    string restofname = Translation::TranslateName(\u0026unit-\u003ename, false);\n                    firstname[0] = toupper(firstname[0]);\n\n                    // if creature has no nickname, restofname will already contain firstname\n                    // no need for double output\n                    if (restofname.compare(0, firstname.length(), firstname) != 0)\n                        out.print(\"%s \", firstname.c_str());\n                    out.print(\"%s \", restofname.c_str());\n                }\n                else\n                {\n                    // happens with unnamed zombies and resurrected body parts\n                    out.print(\"Unnamed creature \");\n                }\n\n                auto death = df::incident::find(unit-\u003ecounters.death_id);\n                bool missing = false;\n                if (death \u0026\u0026 !death-\u003eflags.bits.discovered)\n                {\n                    missing = true;\n                }\n\n                out.print(\"born in %d, cursed in %d to be a %s. (%s%s%s)\\n\",\n                    unit-\u003ebirth_year,\n                    unit-\u003ecurse_year,\n                    curse_names [static_cast\u003csize_t\u003e(cursetype)].c_str(),\n                    // technically most cursed creatures are undead,\n                    // therefore output 'active' if they are not completely dead\n                    unit-\u003eflags2.bits.killed ? \"deceased\" : \"active\",\n                    unit-\u003eflags3.bits.ghostly ? \"-ghostly\" : \"\",\n                    missing ? \"-missing\" : \"\"\n                );\n\n                if (missing)\n                {\n                    out.print(\"- You can use 'tweak clear-missing' to allow engraving a memorial easier.\\n\");\n                }\n\n                // dump all curse flags on demand\n                if (verbose)\n                {\n                    out \u003c\u003c \"Curse flags: \"\n                        \u003c\u003c bitfield_to_string(unit-\u003ecurse.add_tags1) \u003c\u003c endl\n                        \u003c\u003c bitfield_to_string(unit-\u003ecurse.add_tags2) \u003c\u003c endl;\n                }\n            }\n        }\n    }\n\n    if (checkWholeMap)\n        out.print(\"Number of cursed creatures on map: %zd \\n\", cursecount);\n    else\n        out.print(\"Number of cursed creatures on tile: %zd \\n\", cursecount);\n\n    return CR_OK;\n}\n```","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1579840777,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3Nzk4ODE5Ng==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-577988196"},"message":"Thanks for the patch! I'll try to get it merged properly.\n\nAs for git claiming everything was up-to-date, what did you run to determine that? Confusingly, `git push` will sometimes report this, but it means that the remote version (GitHub) is up-to-date with your local changes, not that your local version is up-to-date with the remote. (And I'm pretty sure jsoncpp-sub shouldn't be changing by itself, but maybe the build process does something weird with it on Windows.)","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1579857442,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3ODA1MTU1NQ==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-578051555"},"message":"\"git status\" lies to claim things are \"up to date\", when all it does is to check that there are no local  changes that haven't been committed. Attempting to fetch and pull from origin resulted in the claim there was no change as well (and no indication of anything being downloaded).\n\njsoncpp-sub started changing on Windows sometime within the last year or so, but didn't earlier, so something in the build process has changed to at least \"touch\" it.\n\nI have no idea why the console file spawned by a new branch from develop on github would require a manual merge with the unchanged (i.e. never even looked at locally) version downloaded from develop. Given that develop apparently is in conflict with itself, I'm not sure even nuking the local dfhack installation would resolve it. Well, it needs nuking anyway, as apparently it refuses to let me back out of merging the file (I tried to see if only the timestamp of jsoncpp-sub changed in a branch that might not be corrupted, with no changes to the files within, as a vague memory indicates, but the state of the whole directory is FUBAR and thus completely unreliable).","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1579875842,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3ODE1MDYwMQ==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-578150601"},"message":"Yeah, `git status` does that too. `git merge --abort` should back out of a failed merge and let you try again; if not, `git reset --hard` would probably work (as long as you don't care about any local changes).","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1579890341,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3ODE1MzY5Mg==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-578153692"},"message":"I believe I tried --abort and it still demanded me to merge before I was even allowed to switch the branch. I nuked it to ensure a clean, uncorrupted slate, rather than trusting that reset would both reset it to a useful state (which it probably wouldn't, as it would  probably be an old one), and that it wouldn't leave junk behind.","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1579890341,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDM0MzQyNzM0OQ=="},"target":"2e8ec52115c6afda89298c27d000a847ccbfd4c6bf977ad462e74950656a94c8","message":"I believe I tried --abort and it still demanded me to merge before I was even allowed to switch the branch. I nuked it to ensure a clean, uncorrupted slate, rather than trusting that reset would both reset it to a useful state (which it probably wouldn't, as it would  probably be an old one), and that it wouldn't leave junk behind.\n\nEdit: Nuking didn't help, but I think I know why things are broken, but not how to fix them. The placeholder \"master\" and \"develop\" branch copies on my DFHack account on github are ancient, and something within a recent update broke them. What I need to do is to replace the garbage with the current state of these branches, but the only command the web page interface allows is pull requests, (no pull or fetch interface is provided), and that was strongly discouraged when I tried it several years ago. Thus, I tried to push a fresh (nuked again) local copy of develop up into the old garbage one, only to again be met by the message that I have to merge to proceed, and again have the local copy destroyed by it, as the command git recommended (git merge --quit) apparently resulted in a corrupt state where it remembers that it can't allow anything without a merge, but doesn't remember what it was supposed to merge, so \"git merge --abort\" doesn't work at that stage at least.","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1579913858,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3ODM1ODA4NQ==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-578358085"},"message":"`git reset --hard` will usually get you out of weird merge states (although it will get rid of *all* of your noncommitted changes, so use with caution). Regarding your develop branch, looks like you made [this commit](https://github.com/PatrikLundell/dfhack/commit/944bca7ae9a7f51f8be392c84e8f9b5ae49c1a8f) to it in 2017, which either didn't make it into DFHack or had its ID changed when it did. For reference, I'm looking at:\n* https://github.com/PatrikLundell/dfhack/tree/master (\"This branch is 935 commits behind DFHack:master.\" - easy to update with DFHack's master branch)\n* https://github.com/PatrikLundell/dfhack/tree/develop (\"This branch is 1 commit ahead, 1084 commits behind DFHack:develop.\" - harder to update with DFHack's develop branch, unless you're OK with overwriting this commit - see below)\n\nIn order to update [your fork](https://github.com/PatrikLundell/dfhack)'s branches, [this help page](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) may help. The way I usually do this is by adding a second remote - something like this should work (I'm assuming your fork is `origin` and DFHack/dfhack is `upstream`):\n\n```sh\ngit remote add upstream https://github.com/DFHack/dfhack  # if you haven't yet\ngit checkout -b some-branch  # makes the next step easier\ngit fetch upstream master:master develop:develop  # updates your local master \u0026 develop branches with this repo's\ngit push origin master\ngit push origin develop --force  # the --force will overwrite your extra commit on your develop branch\n```","files":null},{"type":6,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1579913858,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDM0MzU4NjIzNw=="},"target":"5e06ef405056938e3410bf9e9dab6047c24f6356636faa1339594f9399ff861c","message":"`git reset --hard` will usually get you out of weird merge states (although it will get rid of *all* of your noncommitted changes, so use with caution). Regarding your develop branch, looks like you made [this commit](https://github.com/PatrikLundell/dfhack/commit/944bca7ae9a7f51f8be392c84e8f9b5ae49c1a8f) to it in 2017, which either didn't make it into DFHack or had its ID changed when it did. For reference, I'm looking at:\n* https://github.com/PatrikLundell/dfhack/tree/master (\"This branch is 935 commits behind DFHack:master.\" - easy to update with DFHack's master branch)\n* https://github.com/PatrikLundell/dfhack/tree/develop (\"This branch is 1 commit ahead, 1084 commits behind DFHack:develop.\" - harder to update with DFHack's develop branch, unless you're OK with overwriting this commit - see below)\n\nIn order to update [your fork](https://github.com/PatrikLundell/dfhack)'s branches, [this help page](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) may help. The way I usually do this is by adding a second remote - something like this should work (I'm assuming your fork is `origin` and DFHack/dfhack is `upstream`):\n\n```sh\ngit remote add upstream https://github.com/DFHack/dfhack  # if you haven't yet\ngit checkout -b some-temporary-branch-name-here  # makes the next step easier\ngit fetch upstream master:master develop:develop  # updates your local master \u0026 develop branches with this repo's\ngit push origin master\ngit push origin develop --force  # the --force will overwrite your extra commit on your develop branch\n```","files":null},{"type":6,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1579913877,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDM0MzU4NjMyMA=="},"target":"5e06ef405056938e3410bf9e9dab6047c24f6356636faa1339594f9399ff861c","message":"`git reset --hard` will usually get you out of weird merge states (although it will get rid of *all* of your noncommitted changes, so use with caution). Regarding your develop branch, looks like you made [this commit](https://github.com/PatrikLundell/dfhack/commit/944bca7ae9a7f51f8be392c84e8f9b5ae49c1a8f) to it in 2017, which either didn't make it into DFHack or had its ID changed when it did. For reference, I'm looking at:\n* https://github.com/PatrikLundell/dfhack/tree/master (\"This branch is 935 commits behind DFHack:master.\" - easy to update with DFHack's master branch)\n* https://github.com/PatrikLundell/dfhack/tree/develop (\"This branch is 1 commit ahead, 1084 commits behind DFHack:develop.\" - harder to update with DFHack's develop branch, unless you're OK with overwriting this commit - see below)\n\nIn order to update [your fork](https://github.com/PatrikLundell/dfhack)'s branches, [this help page](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) may help. The way I usually do this is by adding a second remote - something like this should work (I'm assuming your fork is `origin` and DFHack/dfhack is `upstream`):\n\n```sh\ngit remote add upstream https://github.com/DFHack/dfhack  # if you haven't yet\ngit checkout -b some-temporary-branch-name-here  # makes the next step easier\ngit fetch upstream master:master develop:develop  # updates your local master \u0026 develop branches with this repo's\ngit push origin master\ngit push origin develop --force  # the --force will overwrite your extra commit on your develop branch\ngit checkout develop  # get back to local develop, now up-to-date\n```","files":null},{"type":6,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1579913900,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDM0MzU4NjQwNw=="},"target":"5e06ef405056938e3410bf9e9dab6047c24f6356636faa1339594f9399ff861c","message":"`git reset --hard` will usually get you out of weird merge states (although it will get rid of *all* of your noncommitted changes, so use with caution). Regarding your develop branch, looks like you made [this commit](https://github.com/PatrikLundell/dfhack/commit/944bca7ae9a7f51f8be392c84e8f9b5ae49c1a8f) to it in 2017, which either didn't make it into DFHack or had its ID changed when it did. For reference, I'm looking at:\n* https://github.com/PatrikLundell/dfhack/tree/master (\"This branch is 935 commits behind DFHack:master.\" - easy to update with DFHack's master branch)\n* https://github.com/PatrikLundell/dfhack/tree/develop (\"This branch is 1 commit ahead, 1084 commits behind DFHack:develop.\" - harder to update with DFHack's develop branch, unless you're OK with overwriting this commit - see below)\n\nIn order to update [your fork](https://github.com/PatrikLundell/dfhack)'s branches, [this help page](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) may help. The way I usually do this is by adding a second remote - something like this should work (I'm assuming your fork is `origin` and DFHack/dfhack is `upstream`):\n\n```sh\ngit remote add upstream https://github.com/DFHack/dfhack  # if you haven't yet\ngit checkout -b some-temporary-branch-name-here  # makes the next step easier\ngit fetch upstream master:master develop:develop  # updates your local master \u0026 develop branches with this repo's\ngit push origin master\ngit push origin develop --force  # the --force will overwrite your extra commit on your develop branch\ngit checkout develop  # get back to local develop, now up-to-date\ngit branch -d temporary-branch-name-from-above  # clean up\n```","files":null},{"type":6,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1579913919,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDM0MzU4NjQ3MA=="},"target":"5e06ef405056938e3410bf9e9dab6047c24f6356636faa1339594f9399ff861c","message":"`git reset --hard` will usually get you out of weird merge states (although it will get rid of *all* of your noncommitted changes, so use with caution). Regarding your develop branch, looks like you made [this commit](https://github.com/PatrikLundell/dfhack/commit/944bca7ae9a7f51f8be392c84e8f9b5ae49c1a8f) to it in 2017, which either didn't make it into DFHack or had its ID changed when it did. For reference, I'm looking at:\n* https://github.com/PatrikLundell/dfhack/tree/master (\"This branch is 935 commits behind DFHack:master.\" - easy to update with DFHack's master branch)\n* https://github.com/PatrikLundell/dfhack/tree/develop (\"This branch is 1 commit ahead, 1084 commits behind DFHack:develop.\" - harder to update with DFHack's develop branch, unless you're OK with overwriting this commit - see below)\n\nIn order to update [your fork](https://github.com/PatrikLundell/dfhack)'s branches, [this help page](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) may help. The way I usually do this is by adding a second remote - something like this should work (I'm assuming your fork is `origin` and DFHack/dfhack is `upstream`):\n\n```sh\ngit remote add upstream https://github.com/DFHack/dfhack  # if you haven't yet\ngit checkout -b some-temporary-branch-name-here  # makes the next step easier\ngit fetch upstream master:master develop:develop  # updates your local master \u0026 develop branches with this repo's\ngit push origin master  # updates your fork's master branch\ngit push origin develop --force  # the --force will overwrite your extra commit on your develop branch\ngit checkout develop  # get back to local develop, now up-to-date\ngit branch -d temporary-branch-name-from-above  # clean up\n```","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1579947956,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3ODM5NDcyOA==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-578394728"},"message":"Thanks. What I needed was the combination of \"git reset --hard\", and \"git push \u003crepo\u003e --force\" (I use \"origin\" and \"upstream\", but swapped, i.e. \"origin\" is the official DFHack one).\n\nI remember the 2017 changes, although I don't remember what happened with them. It may well be then I was told to create temporary branches for each change, rather than \"contaminating\" develop with things that may well wait quite some time for resolution.","files":null},{"type":4,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1581804571,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MzA0MTE3NTMyNw=="},"status":2},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1581804697,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU4NjY0NjAzNQ==","github-url":"https://github.com/DFHack/dfhack/issues/957#issuecomment-586646035"},"message":"Seems to work with @PatrikLundell's fix, thanks!\n```\n[DFHack]# cursecheck verbose\nNo cursor; will check all units on the map.\nShorast Delertoral born in -125, cursed in -1 to be a werebeast. (active)\nCurse flags: \n\nNumber of cursed creatures on map: 1 \n```","files":null}]}