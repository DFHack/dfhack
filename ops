{"version":1,"ops":[{"type":5,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1577928449,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDI5MTY4MTM5OTQ="},"added":["bug"],"removed":[]},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1577928546,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MDEwMDQwNA==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-570100404"},"message":"I'm not entirely familiar with this, so to clarify - are the dwarves collecting growths (other than berries) or nothing at all? Does designating the bilberry bushes for gathering manually lead to the same result? If that's the case, I'm not sure if there's a way to tell in advance whether a plant will produce berries when harvested, but we can investigate.","files":null},{"type":3,"author":{"id":"e5e9ccc1dc3eb3d55cfad169dcbfbaae5afb459c"},"timestamp":1577929095,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MDEwMTA0MQ==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-570101041"},"message":"No. If you manually designate the bilberry bushes with d - p they aren't selected unless there is a fruit there to collect. Similarly if you put these plants in a gather zone, dwarves will not attempt to harvest them unless there's a fruit or whatever. \n\nFrom the wiki: \n\u003e Edible or otherwise usable growths should have [STOCKPILE_PLANT_GROWTH] in their material definitions for proper stockpiling. This also lets them be collected from plant gathering and farming jobs. \n\nI don't really know if they are 'collecting' the leaf/flower growths to be honest. Nothing is produced out of it either way.\n\nI'm roughly trying to repeat [what Patrik Lundell told me on the forum.](http://www.bay12forums.com/smf/index.php?topic=175283.0) His explanation might be more helpful.","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1577941402,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MDExODk1OA==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-570118958"},"message":"Aha, thanks for the forum link. So getplants is making designations that aren't even possible to make in vanilla, then. I'm not sure how complicated this is to address, but yeah, it's definitely a DFHack bug in that case.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578052646,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MDU0NTI2MQ==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-570545261"},"message":"I've thought a bit about the problem, and came up with a few complications that will have to be considered.\nThe Bilberry case is reasonably straightforward, as the basic plant can't be used for anything, and thus there's no vanilla reason to pick a Bilberry at that stage. However:\n- If the \"structure\" part of the Bilberry plant actually is collected, it's ought to be possible to create custom reactions that could use it (like Papyrus doesn't have any usefulness flags associated with it [at least none have been identified], but has to be detected through its paper making reaction).\n- The Strawberry trouble maker has an edible \"structure\" part, and so there is a reasonable reason to pick it before there are any berries on it, but most people would presumably want to skip the picking until the berries are available (starvation being an exception, I guess).\n- I don't know if there's any (vanilla) shrub that has this behavior, but the Date Palm has both edible flower growths and edible fruit growths. As far as I've seen, it seems gathering of the flowers don't have the real world effect of blocking the later ability to pick the fruit (which is fortunate, as gathering zones have no controls that can be used to restrict the gathering), but I can't guarantee that this is a correct observation. If a shrub that sports both usable early time growths and usable late time growths you'd get into a tricky situation, however, as the picking of shrubs removes the shrub, and thus blocks the ability to get the late ripening growth.\n\nIt seems to me that the [STOCKPILE_PLANT_GROWTH] raw tag referenced above gets translated into the stockpile_growths and stockpile_growth_flags arrays in the raw structured inside DF. However, these arrays do not include the structural part of the plant, so the determination of whether to pick that part has to use other info.","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578052646,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzMjE3MTQyMw=="},"target":"106d4bc273fce4663ec2d221b76b09d6dd23772ee1ffb943d75dfe10003fb85c","message":"I've thought a bit about the problem, and came up with a few complications that will have to be considered.\nThe Bilberry case is reasonably straightforward, as the basic plant can't be used for anything, and thus there's no vanilla reason to pick a Bilberry at that stage. However:\n- If the \"structure\" part of the Bilberry plant actually is collected, it's ought to be possible to create custom reactions that could use it (like Papyrus doesn't have any usefulness flags associated with it [at least none have been identified], but has to be detected through its paper making reaction).\n- The Strawberry trouble maker has an edible \"structure\" part, and so there is a reasonable reason to pick it before there are any berries on it, but most people would presumably want to skip the picking until the berries are available (starvation being an exception, I guess).\n- I don't know if there's any (vanilla) shrub that has this behavior, but the Date Palm has both edible flower growths and edible fruit growths. As far as I've seen, it seems gathering of the flowers don't have the real world effect of blocking the later ability to pick the fruit (which is fortunate, as gathering zones have no controls that can be used to restrict the gathering), but I can't guarantee that this is a correct observation. If a shrub that sports both usable early time growths and usable late time growths you'd get into a tricky situation, however, as the picking of shrubs removes the shrub, and thus blocks the ability to get the late ripening growth.\n\nIt seems to me that the [STOCKPILE_PLANT_GROWTH] raw tag referenced above gets translated into the stockpile_growths and stockpile_growth_flags arrays in the raw structures inside DF. However, these arrays do not include the structural part of the plant, so the determination of whether to pick that part has to use other info.","files":null},{"type":3,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1578096965,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MDczNjU0OQ==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-570736549"},"message":"Just located the code DF itself uses for checking if a plant is harvestable (and whether it will allow you to designate it), and it appears to use the following criteria:\n* plant's defined BASIC_MAT is EDIBLE_RAW or EDIBLE_COOKD\n* plant is flagged with THREAD, MILL, EXTRACT_VIAL, EXTRACT_BARREL, or STILL_VIAL\n* plant's defined BASIC_MAT has at least one REACTION_PRODUCT or REACTION_CLASS\n* at least one time-valid plant growth produces SEEDS items whose material is EDIBLE_RAW or EDIBLE_COOKED\n* at least one time-valid plant growth produces PLANT_GROWTH objects whose material has flag 0x26 set (which used to be LEAF_MAT but appears to mean something else now)","files":null},{"type":6,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1578096965,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzMjQ1OTI5Mw=="},"target":"8d69589ccec0efc5e49566c4c9560053082e8832bebe4925d331fe4ee4207cb6","message":"Just located the code DF itself uses for checking if a plant is harvestable (and whether it will allow you to designate it), and it appears to use the following criteria:\n* plant's defined BASIC_MAT is EDIBLE_RAW or EDIBLE_COOKED\n* plant is flagged with THREAD, MILL, EXTRACT_VIAL, EXTRACT_BARREL, or STILL_VIAL\n* plant's defined BASIC_MAT has at least one REACTION_PRODUCT or REACTION_CLASS\n* at least one time-valid plant growth produces SEEDS items whose material is EDIBLE_RAW or EDIBLE_COOKED\n* at least one time-valid plant growth produces PLANT_GROWTH objects whose material has flag 0x26 set (which used to be LEAF_MAT but appears to mean something else now)","files":null},{"type":6,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1578097287,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzMjQ2MDM0Nw=="},"target":"8d69589ccec0efc5e49566c4c9560053082e8832bebe4925d331fe4ee4207cb6","message":"Just located the code DF itself uses for checking if a plant is harvestable (and whether it will allow you to designate it), and it appears to use the following criteria:\n* plant's defined BASIC_MAT is EDIBLE_RAW or EDIBLE_COOKED\n* plant is flagged with THREAD, MILL, EXTRACT_VIAL, EXTRACT_BARREL, or STILL_VIAL\n* plant's defined BASIC_MAT has at least one REACTION_PRODUCT or REACTION_CLASS\n* at least one time-valid plant growth produces SEEDS items whose material is EDIBLE_RAW or EDIBLE_COOKED\n* at least one time-valid plant growth produces PLANT_GROWTH objects whose material has the flag STOCKPILE_PLANT_GROWTH","files":null},{"type":6,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1578097300,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzMjQ2MDQwNw=="},"target":"8d69589ccec0efc5e49566c4c9560053082e8832bebe4925d331fe4ee4207cb6","message":"Just located the code DF itself uses for checking if a plant is harvestable (and whether it will allow you to designate it), and it appears to use the following criteria:\n* plant's defined BASIC_MAT is EDIBLE_RAW or EDIBLE_COOKED\n* plant is flagged with THREAD, MILL, EXTRACT_VIAL, EXTRACT_BARREL, or STILL_VIAL\n* plant's defined BASIC_MAT has at least one REACTION_PRODUCT or REACTION_CLASS\n* at least one time-valid plant growth produces SEEDS items whose material is EDIBLE_RAW or EDIBLE_COOKED\n* at least one time-valid plant growth produces PLANT_GROWTH objects whose material has the flag STOCKPILE_PLANT_GROWTH (formerly LEAF_MAT)","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578246141,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MDc5NjI4Mg==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-570796282"},"message":"I guess the best approach would be to apply the same rules DF uses and leave it up to the players to issue the command at the correct times if they want to get specific time limited parts (just as with the vanilla DF designations, it will lead to confusion for things like strawberries, but at least it's a standard confusion...).","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578246141,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzMjcxMDAxOA=="},"target":"4ed24b572212e181ad8264c52d32fbca8279b04f1f4413c944944a0f50201c1c","message":"I guess the best approach would be to apply the same rules DF uses and leave it up to the players to issue the command at the correct times if they want to get specific time limited parts (just as with the vanilla DF designations, it will lead to confusion for things like strawberries, but at least it's a standard confusion...).\n\nEdit:\n\nI've tried to implement the logic quietust provided, and while I think it works (I've performed some tests, comparing its selections with those made by DF, it's not exactly pretty to match up \"growths\" with \"material\" so it should probably be improved/corrected.\n\nI've added a couple of #includes, for \"df/plant_growth.h\" and #include \"modules/Materials.h\", if I remember correctly (more lines than those are marked as \"changed\", but I don't think there's any net change in them).\n\n```\nREQUIRE_GLOBAL(cur_year_tick);\n\nbool markPlant(const df::plant *plant)\n{\n    const df::plant_raw *plant_raw = world-\u003eraws.plants.all[plant-\u003ematerial];\n    const DFHack::MaterialInfo basic_mat = DFHack::MaterialInfo(plant_raw-\u003ematerial_defs.type_basic_mat, plant_raw-\u003ematerial_defs.idx_basic_mat);\n    \n    if (plant_raw-\u003eflags.is_set(plant_raw_flags::TREE))\n    {\n        return Designations::markPlant(plant);\n    }\n\n    if (basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n        basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n    {\n        return Designations::markPlant(plant);\n    }\n\n    if (plant_raw-\u003eflags.is_set(plant_raw_flags::THREAD) ||\n        plant_raw-\u003eflags.is_set(plant_raw_flags::MILL) ||\n        plant_raw-\u003eflags.is_set(plant_raw_flags::EXTRACT_VIAL) ||\n        plant_raw-\u003eflags.is_set(plant_raw_flags::EXTRACT_BARREL) ||\n        plant_raw-\u003eflags.is_set(plant_raw_flags::EXTRACT_STILL_VIAL))\n    {\n        return Designations::markPlant(plant);\n    }\n\n    if (basic_mat.material-\u003ereaction_product.id.size() \u003e 0 ||\n        basic_mat.material-\u003ereaction_class.size() \u003e 0)\n    {\n        return Designations::markPlant(plant);\n    }\n\n    for (auto i = 0; i \u003c plant_raw-\u003ematerial.size(); i++) \n    {\n        if (plant_raw-\u003ematerial[i]-\u003eflags.is_set(material_flags::SEED_MAT) \u0026\u0026\n            (plant_raw-\u003ematerial[i]-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n             plant_raw-\u003ematerial[i]-\u003eflags.is_set(material_flags::EDIBLE_COOKED)))\n        {\n            for (auto k = 0; k \u003c plant_raw-\u003egrowths.size(); k++)\n            {\n                if (plant_raw-\u003egrowths[k]-\u003ebehavior.bits.has_seed \u0026\u0026\n                    *cur_year_tick \u003e= plant_raw-\u003egrowths[k]-\u003etiming_1 \u0026\u0026\n                    (plant_raw-\u003egrowths[k]-\u003etiming_2 == -1 || \n                     *cur_year_tick \u003c= plant_raw-\u003egrowths[k]-\u003etiming_2)) {\n                    return Designations::markPlant(plant);\n                }\n            }\n        }\n\n        if (plant_raw-\u003ematerial[i]-\u003eflags.is_set(material_flags::LEAF_MAT))  //  The flag really means STOCKPILE_PLANT_GROWTH\n        {\n            for (auto k = 0; k \u003c plant_raw-\u003egrowths.size(); k++)\n            {\n                if (plant_raw-\u003egrowths[k]-\u003eid == plant_raw-\u003ematerial[i]-\u003eid \u0026\u0026\n                    *cur_year_tick \u003e= plant_raw-\u003egrowths[k]-\u003etiming_1 \u0026\u0026\n                    (plant_raw-\u003egrowths[k]-\u003etiming_2 == -1 ||\n                     *cur_year_tick \u003c= plant_raw-\u003egrowths[k]-\u003etiming_2)) {\n                    return Designations::markPlant(plant);\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```\nhas been added after \"REQUIRE_GLOBAL(world);\", and the new function is called instead of \"Designations::markPlants\" towards the end of the \"df_getplants\" function.\n\nBy the way: I guess there's no way to introduce an alias of \"STOCKPILE_PLANT_GROWTH\" for \"LEAF_MAT\" to get a named constant with a suitable name beside the obsolete one in the \"material_flags\" namespace, since it seems to be too cumbersome to replace the obsolete constant? It feels wrong to introduce new usages of the inappropriately named constant...","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578246242,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzMjcxMDIyNQ=="},"target":"4ed24b572212e181ad8264c52d32fbca8279b04f1f4413c944944a0f50201c1c","message":"I guess the best approach would be to apply the same rules DF uses and leave it up to the players to issue the command at the correct times if they want to get specific time limited parts (just as with the vanilla DF designations, it will lead to confusion for things like strawberries, but at least it's a standard confusion...).\n\nEdit:\n\nI've tried to implement the logic quietust provided, and while I think it works (I've performed some tests, comparing its selections with those made by DF, it's not exactly pretty to match up \"growths\" with \"material\" using loops and string comparisons so it should probably be improved/corrected.\n\nI've added a couple of #includes, for \"df/plant_growth.h\" and #include \"modules/Materials.h\", if I remember correctly (more lines than those are marked as \"changed\", but I don't think there's any net change in them).\n\n```\nREQUIRE_GLOBAL(cur_year_tick);\n\nbool markPlant(const df::plant *plant)\n{\n    const df::plant_raw *plant_raw = world-\u003eraws.plants.all[plant-\u003ematerial];\n    const DFHack::MaterialInfo basic_mat = DFHack::MaterialInfo(plant_raw-\u003ematerial_defs.type_basic_mat, plant_raw-\u003ematerial_defs.idx_basic_mat);\n    \n    if (plant_raw-\u003eflags.is_set(plant_raw_flags::TREE))\n    {\n        return Designations::markPlant(plant);\n    }\n\n    if (basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n        basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n    {\n        return Designations::markPlant(plant);\n    }\n\n    if (plant_raw-\u003eflags.is_set(plant_raw_flags::THREAD) ||\n        plant_raw-\u003eflags.is_set(plant_raw_flags::MILL) ||\n        plant_raw-\u003eflags.is_set(plant_raw_flags::EXTRACT_VIAL) ||\n        plant_raw-\u003eflags.is_set(plant_raw_flags::EXTRACT_BARREL) ||\n        plant_raw-\u003eflags.is_set(plant_raw_flags::EXTRACT_STILL_VIAL))\n    {\n        return Designations::markPlant(plant);\n    }\n\n    if (basic_mat.material-\u003ereaction_product.id.size() \u003e 0 ||\n        basic_mat.material-\u003ereaction_class.size() \u003e 0)\n    {\n        return Designations::markPlant(plant);\n    }\n\n    for (auto i = 0; i \u003c plant_raw-\u003ematerial.size(); i++) \n    {\n        if (plant_raw-\u003ematerial[i]-\u003eflags.is_set(material_flags::SEED_MAT) \u0026\u0026\n            (plant_raw-\u003ematerial[i]-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n             plant_raw-\u003ematerial[i]-\u003eflags.is_set(material_flags::EDIBLE_COOKED)))\n        {\n            for (auto k = 0; k \u003c plant_raw-\u003egrowths.size(); k++)\n            {\n                if (plant_raw-\u003egrowths[k]-\u003ebehavior.bits.has_seed \u0026\u0026\n                    *cur_year_tick \u003e= plant_raw-\u003egrowths[k]-\u003etiming_1 \u0026\u0026\n                    (plant_raw-\u003egrowths[k]-\u003etiming_2 == -1 || \n                     *cur_year_tick \u003c= plant_raw-\u003egrowths[k]-\u003etiming_2)) {\n                    return Designations::markPlant(plant);\n                }\n            }\n        }\n\n        if (plant_raw-\u003ematerial[i]-\u003eflags.is_set(material_flags::LEAF_MAT))  //  The flag really means STOCKPILE_PLANT_GROWTH\n        {\n            for (auto k = 0; k \u003c plant_raw-\u003egrowths.size(); k++)\n            {\n                if (plant_raw-\u003egrowths[k]-\u003eid == plant_raw-\u003ematerial[i]-\u003eid \u0026\u0026\n                    *cur_year_tick \u003e= plant_raw-\u003egrowths[k]-\u003etiming_1 \u0026\u0026\n                    (plant_raw-\u003egrowths[k]-\u003etiming_2 == -1 ||\n                     *cur_year_tick \u003c= plant_raw-\u003egrowths[k]-\u003etiming_2)) {\n                    return Designations::markPlant(plant);\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```\nhas been added after \"REQUIRE_GLOBAL(world);\", and the new function is called instead of \"Designations::markPlants\" towards the end of the \"df_getplants\" function.\n\nBy the way: I guess there's no way to introduce an alias of \"STOCKPILE_PLANT_GROWTH\" for \"LEAF_MAT\" to get a named constant with a suitable name beside the obsolete one in the \"material_flags\" namespace, since it seems to be too cumbersome to replace the obsolete constant? It feels wrong to introduce new usages of the inappropriately named constant...","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1578286647,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MTAwMzYyMA==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-571003620"},"message":"Aliases are not possible, but renaming it is easy. What isn't easy is ensuring that everything that used the old name is updated, but if the old name was wrong anyway, I'm fine with renaming it.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578317409,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MTEwNzQzNw==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-571107437"},"message":"Well, just renaming the constant in the definition doesn't count as performing a renaming in my book: The task should involve locating and changing usages as well.\n\nSomething that bothers me with the implementation above is that it doesn't actually make use of the plant's growth state, which may or may not match how DF treats it, i.e. if a shrub is spawned, it assumes the appropriate time-of-year growths are present immediately as well. There's a \"grow_counter\" field in the individual plant, but I don't know if it is used for shrubs (it is for trees). If there is no actual dependency on the plant itself, it might be better to make the evaluation of whether it is ready for picking on the species level (there are a few hundred plants, but potentially thousands of shrubs on an embark).","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578317409,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzMzAyOTAxMQ=="},"target":"6b789c36f3117097e0ea3a0a3edd6779de0324aa076c71bcb9c8d660804250ab","message":"Well, just renaming the constant in the definition doesn't count as performing a renaming in my book: The task should involve locating and changing usages as well.\n\nSomething that bothers me with the implementation above is that it doesn't actually make use of the plant's growth state, which may or may not match how DF treats it, i.e. if a shrub is spawned, it assumes the appropriate time-of-year growths are present immediately as well. There's a \"grow_counter\" field in the individual plant, but I don't know if it is used for shrubs (it is for trees). If there is no actual dependency on the plant itself, it might be better to make the evaluation of whether it is ready for picking on the species level (there are a few hundred plants, but potentially thousands of shrubs on an embark).\n\nEdit: A text search of the dfhack git download (by Windows, which isn't to be trusted), found \"LEAF_MAT\" only in the defining XML file, my modified getplants, and files generated by the XML processing, so a name change should be trivial. I tried to find matches in the hack directory of my LNP DF installation as well, and found nothing there either (as expected).","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578318186,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzMzAzNTIxNw=="},"target":"6b789c36f3117097e0ea3a0a3edd6779de0324aa076c71bcb9c8d660804250ab","message":"Well, just renaming the constant in the definition doesn't count as performing a renaming in my book: The task should involve locating and changing usages as well.\n\nSomething that bothers me with the implementation above is that it doesn't actually make use of the plant's growth state, which may or may not match how DF treats it, i.e. if a shrub is spawned, it assumes the appropriate time-of-year growths are present immediately as well. There's a \"grow_counter\" field in the individual plant, but I don't know if it is used for shrubs (it is for trees). If there is no actual dependency on the plant itself, it might be better to make the evaluation of whether it is ready for picking on the species level (there are a few hundred plants, but potentially thousands of shrubs on an embark).\n\nEdit: A text search of the dfhack git download (by Windows, which isn't to be trusted), found \"LEAF_MAT\" only in the defining XML file, my modified getplants, and files generated by the XML processing, so a name change should be trivial. I tried to find matches in the hack directory of my LNP DF installation as well, and found nothing there either (as expected). \nHm, I was sure I've seen quietust indicate changing the flag was too cumbersome somewhere, but am unable to locate it. Regardless, it seems quietust did actually change the flag 3 days ago, based on the editing history of the post above, so I guess we can close this silly tangent.","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1578322290,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MTE2NjYyNg==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-571166626"},"message":"Looks like there are a couple occurrences in scripts: https://github.com/DFHack/scripts/search?utf8=%E2%9C%93\u0026q=leaf_mat\u0026type= (but I only see the definition in df-structures, and nothing in dfhack)","files":null},{"type":3,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1578537651,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MjM1NTk1OA==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-572355958"},"message":"Your plant growth checks aren't quite right - the seed one shouldn't look at SEED_MAT or behavior.bits.has_seed, but should instead check the growth's item_type (and compare to SEEDS / PLANT_GROWTH) and then load the material specified by mat_type/mat_index (which might not even belong to that plant) to check the necessary flags.\n\nIt's probably best to iterate across the growths array _once_ (to avoid duplicating the time validity check), since that's what DF itself does.","files":null},{"type":3,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1578537779,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MjM1NjQ0Nw==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-572356447"},"message":"Also, regarding LEAF_MAT, that's what it *used* to be called back in version 0.34.11 - Toady renamed it when he added plant growths in 0.40.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578587566,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3MjQ5MDQwMw==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-572490403"},"message":"Thanks for the feedback, quietust.\n\nI usually assume the need for a change of a name to be caused by DF changing the use, rather than the person originally naming it having made an error. That's why I try to use the term \"obsolete\" rather than \"incorrect\".","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578587566,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzNTE2NDg0NQ=="},"target":"fd31bbafa4cab2a61ded2b978fe85731051b1267d31897bc8744c3b480a83b49","message":"Thanks for the feedback, quietust.\n\nI usually assume the need for a change of a name to be caused by DF changing the use, rather than the person originally naming it having made an error. That's why I try to use the term \"obsolete\" rather than \"incorrect\".\n\nEdit:\nI probably misunderstand quietust, because checking a growth's item_type for SEEDS causes the checks to fail to find FRUIT/POD containing edible seeds (all growths seem to be of the item_type PLANT_GROWTH in the small sample I've looked at).\nThe trouble plants seem to be:\nBAMBARA_GROUND_NUT, STRING_BEAN, BROAD_BEAN, LENTIL, MUNG_BEAN, PEA, PEANUT, RED_BEAN, SOYBEAN, and URAD_BEAN, (I have missed some in that list, e.g. COWPEA), i.e. the ones that have inedible growths containing edible seeds. I recall having heard of trouble with collection of those kinds of plants, but as you can't make booze out of them I haven't thought about it further, so I don't know if DF can't collect them, can't designate them (but collect them once designated by DFHack), or if there was something else entirely.\nThus, at the moment my issue seems to be to fulfill the \"at least one time-valid plant growth produces SEEDS items whose material is EDIBLE_RAW or EDIBLE_COOKED\" criterion. I can find the growth, but its material isn't edible, nor does it refer to any seed material. The only lead I have is the \u003cgrowth\u003e.behavior.has_seed flag, but without any indication of how to get the seed (without iterating over \u003eplant_raw\u003e.material) and its material.\n(Interestingly enough, the strawberry fruit growth doesn't have its behavior.has_seed flag set, so it doesn't seem to indicate whether the growth contains seeds, but possibly whether it contains edible ones).\n\nHm, changing the code to use the .has_seed flag and get the material from \u003cplant_raw\u003e.material_defs.type_seed/idx_seed allows the code to designate the trouble shrubs while DF doesn't. However, observing a plant gatherer trying to pick such a plant up shows nothing in the inventory and the plant remaining, and running \"getplant URAD_BEAN\" again after it was \"picked up\" designated it again, a plant gatherer went there, and failed to pick anything so it doesn't actually work. The issue with beans I seem to recall _might_ be that you can grow them (and get seeds through harvesting) assuming you get seeds from the outside, but can't gather them.\n\nI've ended up with this code (it ignores the edible seed criterion that doesn't seem to work, and adds a little feedback about things that are out of season, since we need to check the time internally anyway):\n```\n// (un)designate matching plants for gathering/cutting\n\n#include \u003cset\u003e\n\n#include \"Core.h\"\n#include \"Console.h\"\n#include \"Export.h\"\n#include \"PluginManager.h\"\n#include \"DataDefs.h\"\n#include \"TileTypes.h\"\n\n#include \"df/map_block.h\"\n#include \"df/plant.h\"\n#include \"df/plant_growth.h\"\n#include \"df/plant_raw.h\"\n#include \"df/tile_dig_designation.h\"\n#include \"df/world.h\"\n\n#include \"modules/Designations.h\"\n#include \"modules/Maps.h\"\n#include \"modules/Materials.h\"\n\nusing std::string;\nusing std::vector;\nusing std::set;\n\nusing namespace DFHack;\nusing namespace df::enums;\n\nDFHACK_PLUGIN(\"getplants\");\nREQUIRE_GLOBAL(world);\nREQUIRE_GLOBAL(cur_year_tick);\n\nenum class selectability {\n    Selectable,\n    Grass,\n    Nonselectable,\n    OutOfSeason,\n    Unselected\n};\n\n//selectability selectablePlant(color_ostream \u0026out, const df::plant_raw *plant)\nselectability selectablePlant(const df::plant_raw *plant)\n{\n    const DFHack::MaterialInfo basic_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_basic_mat, plant-\u003ematerial_defs.idx_basic_mat);\n    bool outOfSeason = false;\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::TREE))\n    {\n//        out.print(\"%s is a selectable tree\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n    else if (plant-\u003eflags.is_set(plant_raw_flags::GRASS))\n    {\n//        out.print(\"%s is a non selectable Grass\\n\", plant-\u003eid.c_str());\n        return selectability::Grass;\n    }\n\n    if (basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n        basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n    {\n//        out.print(\"%s is a edible\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::THREAD) ||\n        plant-\u003eflags.is_set(plant_raw_flags::MILL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_VIAL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_BARREL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_STILL_VIAL))\n    {\n//        out.print(\"%s is thread/mill/extract\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (basic_mat.material-\u003ereaction_product.id.size() \u003e 0 ||\n        basic_mat.material-\u003ereaction_class.size() \u003e 0)\n    {\n//        out.print(\"%s has a reaction\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    for (auto i = 0; i \u003c plant-\u003egrowths.size(); i++)\n    {\n        if (plant-\u003egrowths[i]-\u003eitem_type == df::item_type::PLANT_GROWTH)\n        {\n            const DFHack::MaterialInfo growth_mat = DFHack::MaterialInfo(plant-\u003egrowths[i]-\u003emat_type, plant-\u003egrowths[i]-\u003emat_index);\n            if (growth_mat.material-\u003eflags.is_set(material_flags::STOCKPILE_PLANT_GROWTH))\n            {\n                if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                    (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                        *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                {\n//                    out.print(\"%s has a stockpile growth\\n\", plant-\u003eid.c_str());\n                    return selectability::Selectable;\n                }\n                else\n                {\n                    outOfSeason = true;\n                }\n            }\n/*            else if (plant-\u003egrowths[i]-\u003ebehavior.bits.has_seed)  //  This code designates beans, etc. when DF doesn't, but plant gatherers still fail to collect anything.\n            {\n                const DFHack::MaterialInfo seed_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_seed, plant-\u003ematerial_defs.idx_seed);\n\n                if (seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n                    seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n                {\n                    if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                        (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                            *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                    {\n                        return selectability::Selectable;\n                    }\n                    else\n                    {\n                        outOfSeason = true;\n                    }\n                }\n            }  */          \n        }\n    }\n\n    if (outOfSeason)\n    {\n//        out.print(\"%s has an out of season growth\\n\", plant-\u003eid.c_str());\n        return selectability::OutOfSeason;\n    }\n    else\n    {\n//        out.printerr(\"%s cannot be gathered\\n\", plant-\u003eid.c_str());\n        return selectability::Nonselectable;\n    }\n}\n\ncommand_result df_getplants (color_ostream \u0026out, vector \u003cstring\u003e \u0026 parameters)\n{\n    string plantMatStr = \"\";\n    std::vector\u003cselectability\u003e plantSelections;\n    set\u003cstring\u003e plantNames;\n    bool deselect = false, exclude = false, treesonly = false, shrubsonly = false, all = false;\n\n    int count = 0;\n\n    plantSelections.resize(world-\u003eraws.plants.all.size());\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        plantSelections[i] = selectability::Unselected;\n    }\n    \n    bool anyPlantsSelected = false;\n\n    for (size_t i = 0; i \u003c parameters.size(); i++)\n    {\n        if(parameters[i] == \"help\" || parameters[i] == \"?\")\n            return CR_WRONG_USAGE;\n        else if(parameters[i] == \"-t\")\n            treesonly = true;\n        else if(parameters[i] == \"-s\")\n            shrubsonly = true;\n        else if(parameters[i] == \"-c\")\n            deselect = true;\n        else if(parameters[i] == \"-x\")\n            exclude = true;\n        else if(parameters[i] == \"-a\")\n            all = true;\n        else\n            plantNames.insert(parameters[i]);\n    }\n    if (treesonly \u0026\u0026 shrubsonly)\n    {\n        out.printerr(\"Cannot specify both -t and -s at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 exclude)\n    {\n        out.printerr(\"Cannot specify both -a and -x at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 plantNames.size())\n    {\n        out.printerr(\"Cannot specify -a along with plant IDs!\\n\");\n        return CR_WRONG_USAGE;\n    }\n\n    CoreSuspender suspend;\n\n    for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n    {\n        df::plant_raw *plant = world-\u003eraws.plants.all[i];\n        if (all)\n        {\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n        }\n         else if (plantNames.find(plant-\u003eid) != plantNames.end())\n        {\n            plantNames.erase(plant-\u003eid);\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n            switch (plantSelections[i])\n            {\n            case selectability::Grass:\n            {\n                out.printerr(\"%s is a Grass, and those can not be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n\n            case selectability::Nonselectable:\n            {\n                out.printerr(\"%s does not have any parts that can be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::OutOfSeason:\n            {\n                out.printerr(\"%s is out of season, with nothing that can be gathered now\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::Selectable:\n                break;\n\n            case selectability::Unselected:\n                break;  //  We won't get to this option\n            }\n        }\n    }\n    if (plantNames.size() \u003e 0)\n    {\n        out.printerr(\"Invalid plant ID(s):\");\n        for (set\u003cstring\u003e::const_iterator it = plantNames.begin(); it != plantNames.end(); it++)\n            out.printerr(\" %s\", it-\u003ec_str());\n        out.printerr(\"\\n\");\n        return CR_FAILURE;\n    }\n\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        if (plantSelections[i] == selectability::OutOfSeason ||\n            plantSelections[i] == selectability::Selectable)\n        {\n            anyPlantsSelected = true;\n            break;\n        }\n    }\n\n    if (!anyPlantsSelected)\n    {\n        out.print(\"Valid plant IDs:\\n\");\n        for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n        {\n            df::plant_raw *plant = world-\u003eraws.plants.all[i];\n//            switch (selectablePlant(out, plant))\n            switch (selectablePlant(plant))\n                {\n            case selectability::Grass:\n            case selectability::Nonselectable:\n                continue;\n\n            case selectability::OutOfSeason:\n            {\n                out.print(\"* (shrub) %s - %s is out of season\\n\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Selectable:\n            {\n                out.print(\"* (%s) %s - %s\\n\", plant-\u003eflags.is_set(plant_raw_flags::TREE) ? \"tree\" : \"shrub\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Unselected:  //  Should never get this alternative\n                break;\n            }\n        }\n        return CR_OK;\n    }\n\n    count = 0;\n    for (size_t i = 0; i \u003c world-\u003eplants.all.size(); i++)\n    {\n        const df::plant *plant = world-\u003eplants.all[i];\n        df::map_block *cur = Maps::getTileBlock(plant-\u003epos);\n        bool dirty = false;\n\n        int x = plant-\u003epos.x % 16;\n        int y = plant-\u003epos.y % 16;\n        if (plantSelections[plant-\u003ematerial] == selectability::OutOfSeason ||\n            plantSelections[plant-\u003ematerial] == selectability::Selectable)\n        {\n            if (exclude ||\n                plantSelections[plant-\u003ematerial] == selectability::OutOfSeason)\n                continue;\n        }\n        else\n        {\n            if (!exclude)\n                continue;\n        }\n        df::tiletype_shape shape = tileShape(cur-\u003etiletype[x][y]);\n        df::tiletype_material material = tileMaterial(cur-\u003etiletype[x][y]);\n        df::tiletype_special special = tileSpecial(cur-\u003etiletype[x][y]);\n        if (plant-\u003eflags.bits.is_shrub \u0026\u0026 (treesonly || !(shape == tiletype_shape::SHRUB \u0026\u0026 special != tiletype_special::DEAD)))\n            continue;\n        if (!plant-\u003eflags.bits.is_shrub \u0026\u0026 (shrubsonly || !(material == tiletype_material::TREE)))\n            continue;\n        if (cur-\u003edesignation[x][y].bits.hidden)\n            continue;\n        if (deselect \u0026\u0026 Designations::unmarkPlant(plant))\n        {\n            ++count;\n        }\n        if (!deselect \u0026\u0026 Designations::markPlant(plant))\n        {\n            ++count;\n        }\n    }\n    if (count)\n        out.print(\"Updated %d plant designations.\\n\", count);\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_init ( color_ostream \u0026out, vector \u003cPluginCommand\u003e \u0026commands)\n{\n    commands.push_back(PluginCommand(\n        \"getplants\", \"Cut down trees or gather shrubs by ID\",\n        df_getplants, false,\n        \"  Specify the types of trees to cut down and/or shrubs to gather by their\\n\"\n        \"  plant IDs, separated by spaces.\\n\"\n        \"Options:\\n\"\n        \"  -t - Select trees only (exclude shrubs)\\n\"\n        \"  -s - Select shrubs only (exclude trees)\\n\"\n        \"  -c - Clear designations instead of setting them\\n\"\n        \"  -x - Apply selected action to all plants except those specified\\n\"\n        \"  -a - Select every type of plant (obeys -t/-s)\\n\"\n        \"Specifying both -t and -s will have no effect.\\n\"\n        \"If no plant IDs are specified, all valid plant IDs will be listed.\\n\"\n    ));\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_shutdown ( color_ostream \u0026out )\n{\n    return CR_OK;\n}\n```","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578656408,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzNTY5Mjg4Ng=="},"target":"fd31bbafa4cab2a61ded2b978fe85731051b1267d31897bc8744c3b480a83b49","message":"Thanks for the feedback, quietust.\n\nI usually assume the need for a change of a name to be caused by DF changing the use, rather than the person originally naming it having made an error. That's why I try to use the term \"obsolete\" rather than \"incorrect\".\n\nEdit:\nI probably misunderstand quietust, because checking a growth's item_type for SEEDS causes the checks to fail to find FRUIT/POD containing edible seeds (all growths seem to be of the item_type PLANT_GROWTH in the small sample I've looked at).\nThe trouble plants seem to be:\nBAMBARA_GROUND_NUT, STRING_BEAN, BROAD_BEAN, LENTIL, MUNG_BEAN, PEA, PEANUT, RED_BEAN, SOYBEAN, and URAD_BEAN, (I have missed some in that list, e.g. COWPEA), i.e. the ones that have inedible growths containing edible seeds. I recall having heard of trouble with collection of those kinds of plants, but as you can't make booze out of them I haven't thought about it further, so I don't know if DF can't collect them, can't designate them (but collect them once designated by DFHack), or if there was something else entirely.\nThus, at the moment my issue seems to be to fulfill the \"at least one time-valid plant growth produces SEEDS items whose material is EDIBLE_RAW or EDIBLE_COOKED\" criterion. I can find the growth, but its material isn't edible, nor does it refer to any seed material. The only lead I have is the \u003cgrowth\u003e.behavior.has_seed flag, but without any indication of how to get the seed (without iterating over \u003eplant_raw\u003e.material) and its material.\n(Interestingly enough, the strawberry fruit growth doesn't have its behavior.has_seed flag set, so it doesn't seem to indicate whether the growth contains seeds, but possibly whether it contains edible ones).\n\nHm, changing the code to use the .has_seed flag and get the material from \u003cplant_raw\u003e.material_defs.type_seed/idx_seed allows the code to designate the trouble shrubs while DF doesn't. However, observing a plant gatherer trying to pick such a plant up shows nothing in the inventory and the plant remaining, and running \"getplant URAD_BEAN\" again after it was \"picked up\" designated it again, a plant gatherer went there, and failed to pick anything so it doesn't actually work. The issue with beans I seem to recall _might_ be that you can grow them (and get seeds through harvesting) assuming you get seeds from the outside, but can't gather them.\n\nI've ended up with this code (it ignores the edible seed criterion that doesn't seem to work, and adds a little feedback about things that are out of season, since we need to check the time internally anyway):\n```\n// (un)designate matching plants for gathering/cutting\n\n#include \u003cset\u003e\n\n#include \"Core.h\"\n#include \"Console.h\"\n#include \"Export.h\"\n#include \"PluginManager.h\"\n#include \"DataDefs.h\"\n#include \"TileTypes.h\"\n\n#include \"df/map_block.h\"\n#include \"df/plant.h\"\n#include \"df/plant_growth.h\"\n#include \"df/plant_raw.h\"\n#include \"df/tile_dig_designation.h\"\n#include \"df/world.h\"\n\n#include \"modules/Designations.h\"\n#include \"modules/Maps.h\"\n#include \"modules/Materials.h\"\n\nusing std::string;\nusing std::vector;\nusing std::set;\n\nusing namespace DFHack;\nusing namespace df::enums;\n\nDFHACK_PLUGIN(\"getplants\");\nREQUIRE_GLOBAL(world);\nREQUIRE_GLOBAL(cur_year_tick);\n\nenum class selectability {\n    Selectable,\n    Grass,\n    Nonselectable,\n    OutOfSeason,\n    Unselected\n};\n\n//selectability selectablePlant(color_ostream \u0026out, const df::plant_raw *plant)\nselectability selectablePlant(const df::plant_raw *plant)\n{\n    const DFHack::MaterialInfo basic_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_basic_mat, plant-\u003ematerial_defs.idx_basic_mat);\n    bool outOfSeason = false;\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::TREE))\n    {\n//        out.print(\"%s is a selectable tree\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n    else if (plant-\u003eflags.is_set(plant_raw_flags::GRASS))\n    {\n//        out.print(\"%s is a non selectable Grass\\n\", plant-\u003eid.c_str());\n        return selectability::Grass;\n    }\n\n    if (basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n        basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n    {\n//        out.print(\"%s is a edible\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::THREAD) ||\n        plant-\u003eflags.is_set(plant_raw_flags::MILL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_VIAL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_BARREL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_STILL_VIAL))\n    {\n//        out.print(\"%s is thread/mill/extract\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (basic_mat.material-\u003ereaction_product.id.size() \u003e 0 ||\n        basic_mat.material-\u003ereaction_class.size() \u003e 0)\n    {\n//        out.print(\"%s has a reaction\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    for (auto i = 0; i \u003c plant-\u003egrowths.size(); i++)\n    {\n        if (plant-\u003egrowths[i]-\u003eitem_type == df::item_type::PLANT_GROWTH)\n        {\n            const DFHack::MaterialInfo growth_mat = DFHack::MaterialInfo(plant-\u003egrowths[i]-\u003emat_type, plant-\u003egrowths[i]-\u003emat_index);\n            if (growth_mat.material-\u003eflags.is_set(material_flags::STOCKPILE_PLANT_GROWTH))\n            {\n                if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                    (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                        *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                {\n//                    out.print(\"%s has a stockpile growth\\n\", plant-\u003eid.c_str());\n                    return selectability::Selectable;\n                }\n                else\n                {\n                    outOfSeason = true;\n                }\n            }\n/*            else if (plant-\u003egrowths[i]-\u003ebehavior.bits.has_seed)  //  This code designates beans, etc. when DF doesn't, but plant gatherers still fail to collect anything.\n            {\n                const DFHack::MaterialInfo seed_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_seed, plant-\u003ematerial_defs.idx_seed);\n\n                if (seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n                    seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n                {\n                    if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                        (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                            *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                    {\n                        return selectability::Selectable;\n                    }\n                    else\n                    {\n                        outOfSeason = true;\n                    }\n                }\n            }  */          \n        }\n    }\n\n    if (outOfSeason)\n    {\n//        out.print(\"%s has an out of season growth\\n\", plant-\u003eid.c_str());\n        return selectability::OutOfSeason;\n    }\n    else\n    {\n//        out.printerr(\"%s cannot be gathered\\n\", plant-\u003eid.c_str());\n        return selectability::Nonselectable;\n    }\n}\n\ncommand_result df_getplants (color_ostream \u0026out, vector \u003cstring\u003e \u0026 parameters)\n{\n    string plantMatStr = \"\";\n    std::vector\u003cselectability\u003e plantSelections;\n    set\u003cstring\u003e plantNames;\n    bool deselect = false, exclude = false, treesonly = false, shrubsonly = false, all = false;\n\n    int count = 0;\n\n    plantSelections.resize(world-\u003eraws.plants.all.size());\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        plantSelections[i] = selectability::Unselected;\n    }\n    \n    bool anyPlantsSelected = false;\n\n    for (size_t i = 0; i \u003c parameters.size(); i++)\n    {\n        if(parameters[i] == \"help\" || parameters[i] == \"?\")\n            return CR_WRONG_USAGE;\n        else if(parameters[i] == \"-t\")\n            treesonly = true;\n        else if(parameters[i] == \"-s\")\n            shrubsonly = true;\n        else if(parameters[i] == \"-c\")\n            deselect = true;\n        else if(parameters[i] == \"-x\")\n            exclude = true;\n        else if(parameters[i] == \"-a\")\n            all = true;\n        else\n            plantNames.insert(parameters[i]);\n    }\n    if (treesonly \u0026\u0026 shrubsonly)\n    {\n        out.printerr(\"Cannot specify both -t and -s at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 exclude)\n    {\n        out.printerr(\"Cannot specify both -a and -x at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 plantNames.size())\n    {\n        out.printerr(\"Cannot specify -a along with plant IDs!\\n\");\n        return CR_WRONG_USAGE;\n    }\n\n    CoreSuspender suspend;\n\n    for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n    {\n        df::plant_raw *plant = world-\u003eraws.plants.all[i];\n        if (all)\n        {\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n        }\n         else if (plantNames.find(plant-\u003eid) != plantNames.end())\n        {\n            plantNames.erase(plant-\u003eid);\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n            switch (plantSelections[i])\n            {\n            case selectability::Grass:\n            {\n                out.printerr(\"%s is a Grass, and those can not be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n\n            case selectability::Nonselectable:\n            {\n                out.printerr(\"%s does not have any parts that can be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::OutOfSeason:\n            {\n                out.printerr(\"%s is out of season, with nothing that can be gathered now\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::Selectable:\n                break;\n\n            case selectability::Unselected:\n                break;  //  We won't get to this option\n            }\n        }\n    }\n    if (plantNames.size() \u003e 0)\n    {\n        out.printerr(\"Invalid plant ID(s):\");\n        for (set\u003cstring\u003e::const_iterator it = plantNames.begin(); it != plantNames.end(); it++)\n            out.printerr(\" %s\", it-\u003ec_str());\n        out.printerr(\"\\n\");\n        return CR_FAILURE;\n    }\n\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        if (plantSelections[i] == selectability::OutOfSeason ||\n            plantSelections[i] == selectability::Selectable)\n        {\n            anyPlantsSelected = true;\n            break;\n        }\n    }\n\n    if (!anyPlantsSelected)\n    {\n        out.print(\"Valid plant IDs:\\n\");\n        for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n        {\n            df::plant_raw *plant = world-\u003eraws.plants.all[i];\n//            switch (selectablePlant(out, plant))\n            switch (selectablePlant(plant))\n                {\n            case selectability::Grass:\n            case selectability::Nonselectable:\n                continue;\n\n            case selectability::OutOfSeason:\n            {\n                out.print(\"* (shrub) %s - %s is out of season\\n\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Selectable:\n            {\n                out.print(\"* (%s) %s - %s\\n\", plant-\u003eflags.is_set(plant_raw_flags::TREE) ? \"tree\" : \"shrub\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Unselected:  //  Should never get this alternative\n                break;\n            }\n        }\n        return CR_OK;\n    }\n\n    count = 0;\n    for (size_t i = 0; i \u003c world-\u003eplants.all.size(); i++)\n    {\n        const df::plant *plant = world-\u003eplants.all[i];\n        df::map_block *cur = Maps::getTileBlock(plant-\u003epos);\n        bool dirty = false;\n\n        int x = plant-\u003epos.x % 16;\n        int y = plant-\u003epos.y % 16;\n        if (plantSelections[plant-\u003ematerial] == selectability::OutOfSeason ||\n            plantSelections[plant-\u003ematerial] == selectability::Selectable)\n        {\n            if (exclude ||\n                plantSelections[plant-\u003ematerial] == selectability::OutOfSeason)\n                continue;\n        }\n        else\n        {\n            if (!exclude)\n                continue;\n        }\n        df::tiletype_shape shape = tileShape(cur-\u003etiletype[x][y]);\n        df::tiletype_material material = tileMaterial(cur-\u003etiletype[x][y]);\n        df::tiletype_special special = tileSpecial(cur-\u003etiletype[x][y]);\n        if (plant-\u003eflags.bits.is_shrub \u0026\u0026 (treesonly || !(shape == tiletype_shape::SHRUB \u0026\u0026 special != tiletype_special::DEAD)))\n            continue;\n        if (!plant-\u003eflags.bits.is_shrub \u0026\u0026 (shrubsonly || !(material == tiletype_material::TREE)))\n            continue;\n        if (cur-\u003edesignation[x][y].bits.hidden)\n            continue;\n        if (deselect \u0026\u0026 Designations::unmarkPlant(plant))\n        {\n            ++count;\n        }\n        if (!deselect \u0026\u0026 Designations::markPlant(plant))\n        {\n            ++count;\n        }\n    }\n    if (count)\n        out.print(\"Updated %d plant designations.\\n\", count);\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_init ( color_ostream \u0026out, vector \u003cPluginCommand\u003e \u0026commands)\n{\n    commands.push_back(PluginCommand(\n        \"getplants\", \"Cut down trees or gather shrubs by ID\",\n        df_getplants, false,\n        \"  Specify the types of trees to cut down and/or shrubs to gather by their\\n\"\n        \"  plant IDs, separated by spaces.\\n\"\n        \"Options:\\n\"\n        \"  -t - Select trees only (exclude shrubs)\\n\"\n        \"  -s - Select shrubs only (exclude trees)\\n\"\n        \"  -c - Clear designations instead of setting them\\n\"\n        \"  -x - Apply selected action to all plants except those specified\\n\"\n        \"  -a - Select every type of plant (obeys -t/-s)\\n\"\n        \"Specifying both -t and -s will have no effect.\\n\"\n        \"If no plant IDs are specified, all valid plant IDs will be listed.\\n\"\n    ));\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_shutdown ( color_ostream \u0026out )\n{\n    return CR_OK;\n}\n```\n\nEdit 2:\nI ran a script checking the item_type of all growths, and SEEDS does indeed exist. However, all of them are nuts (Macadamia, Almond, Ginko, Hazel, Pecan, Walnut, Oak, Candlenut), and so won't apply to any vanilla shrubs (but could apply to modded raws, of course, and thus ought to be checked).","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578657267,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzNTcwODU4OQ=="},"target":"fd31bbafa4cab2a61ded2b978fe85731051b1267d31897bc8744c3b480a83b49","message":"Thanks for the feedback, quietust.\n\nI usually assume the need for a change of a name to be caused by DF changing the use, rather than the person originally naming it having made an error. That's why I try to use the term \"obsolete\" rather than \"incorrect\".\n\nEdit:\nI probably misunderstand quietust, because checking a growth's item_type for SEEDS causes the checks to fail to find FRUIT/POD containing edible seeds (all growths seem to be of the item_type PLANT_GROWTH in the small sample I've looked at).\nThe trouble plants seem to be:\nBAMBARA_GROUND_NUT, STRING_BEAN, BROAD_BEAN, LENTIL, MUNG_BEAN, PEA, PEANUT, RED_BEAN, SOYBEAN, and URAD_BEAN, (I have missed some in that list, e.g. COWPEA), i.e. the ones that have inedible growths containing edible seeds. I recall having heard of trouble with collection of those kinds of plants, but as you can't make booze out of them I haven't thought about it further, so I don't know if DF can't collect them, can't designate them (but collect them once designated by DFHack), or if there was something else entirely.\nThus, at the moment my issue seems to be to fulfill the \"at least one time-valid plant growth produces SEEDS items whose material is EDIBLE_RAW or EDIBLE_COOKED\" criterion. I can find the growth, but its material isn't edible, nor does it refer to any seed material. The only lead I have is the \u003cgrowth\u003e.behavior.has_seed flag, but without any indication of how to get the seed (without iterating over \u003eplant_raw\u003e.material) and its material.\n(Interestingly enough, the strawberry fruit growth doesn't have its behavior.has_seed flag set, so it doesn't seem to indicate whether the growth contains seeds, but possibly whether it contains edible ones).\n\nHm, changing the code to use the .has_seed flag and get the material from \u003cplant_raw\u003e.material_defs.type_seed/idx_seed allows the code to designate the trouble shrubs while DF doesn't. However, observing a plant gatherer trying to pick such a plant up shows nothing in the inventory and the plant remaining, and running \"getplant URAD_BEAN\" again after it was \"picked up\" designated it again, a plant gatherer went there, and failed to pick anything so it doesn't actually work. The issue with beans I seem to recall _might_ be that you can grow them (and get seeds through harvesting) assuming you get seeds from the outside, but can't gather them.\n\nI've ended up with this code (it ignores the edible seed criterion that doesn't seem to work, and adds a little feedback about things that are out of season, since we need to check the time internally anyway):\n```\n// (un)designate matching plants for gathering/cutting\n\n#include \u003cset\u003e\n\n#include \"Core.h\"\n#include \"Console.h\"\n#include \"Export.h\"\n#include \"PluginManager.h\"\n#include \"DataDefs.h\"\n#include \"TileTypes.h\"\n\n#include \"df/map_block.h\"\n#include \"df/plant.h\"\n#include \"df/plant_growth.h\"\n#include \"df/plant_raw.h\"\n#include \"df/tile_dig_designation.h\"\n#include \"df/world.h\"\n\n#include \"modules/Designations.h\"\n#include \"modules/Maps.h\"\n#include \"modules/Materials.h\"\n\nusing std::string;\nusing std::vector;\nusing std::set;\n\nusing namespace DFHack;\nusing namespace df::enums;\n\nDFHACK_PLUGIN(\"getplants\");\nREQUIRE_GLOBAL(world);\nREQUIRE_GLOBAL(cur_year_tick);\n\nenum class selectability {\n    Selectable,\n    Grass,\n    Nonselectable,\n    OutOfSeason,\n    Unselected\n};\n\n//selectability selectablePlant(color_ostream \u0026out, const df::plant_raw *plant)\nselectability selectablePlant(const df::plant_raw *plant)\n{\n    const DFHack::MaterialInfo basic_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_basic_mat, plant-\u003ematerial_defs.idx_basic_mat);\n    bool outOfSeason = false;\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::TREE))\n    {\n//        out.print(\"%s is a selectable tree\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n    else if (plant-\u003eflags.is_set(plant_raw_flags::GRASS))\n    {\n//        out.print(\"%s is a non selectable Grass\\n\", plant-\u003eid.c_str());\n        return selectability::Grass;\n    }\n\n    if (basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n        basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n    {\n//        out.print(\"%s is a edible\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::THREAD) ||\n        plant-\u003eflags.is_set(plant_raw_flags::MILL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_VIAL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_BARREL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_STILL_VIAL))\n    {\n//        out.print(\"%s is thread/mill/extract\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (basic_mat.material-\u003ereaction_product.id.size() \u003e 0 ||\n        basic_mat.material-\u003ereaction_class.size() \u003e 0)\n    {\n//        out.print(\"%s has a reaction\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    for (auto i = 0; i \u003c plant-\u003egrowths.size(); i++)\n    {\n        if (plant-\u003egrowths[i]-\u003eitem_type == df::item_type::PLANT_GROWTH)\n        {\n            const DFHack::MaterialInfo growth_mat = DFHack::MaterialInfo(plant-\u003egrowths[i]-\u003emat_type, plant-\u003egrowths[i]-\u003emat_index);\n            if (growth_mat.material-\u003eflags.is_set(material_flags::STOCKPILE_PLANT_GROWTH))\n            {\n                if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                    (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                        *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                {\n//                    out.print(\"%s has a stockpile growth\\n\", plant-\u003eid.c_str());\n                    return selectability::Selectable;\n                }\n                else\n                {\n                    outOfSeason = true;\n                }\n            }\n/*            else if (plant-\u003egrowths[i]-\u003ebehavior.bits.has_seed)  //  This code designates beans, etc. when DF doesn't, but plant gatherers still fail to collect anything.\n            {\n                const DFHack::MaterialInfo seed_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_seed, plant-\u003ematerial_defs.idx_seed);\n\n                if (seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n                    seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n                {\n                    if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                        (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                            *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                    {\n                        return selectability::Selectable;\n                    }\n                    else\n                    {\n                        outOfSeason = true;\n                    }\n                }\n            }  */          \n        }\n    }\n\n    if (outOfSeason)\n    {\n//        out.print(\"%s has an out of season growth\\n\", plant-\u003eid.c_str());\n        return selectability::OutOfSeason;\n    }\n    else\n    {\n//        out.printerr(\"%s cannot be gathered\\n\", plant-\u003eid.c_str());\n        return selectability::Nonselectable;\n    }\n}\n\ncommand_result df_getplants (color_ostream \u0026out, vector \u003cstring\u003e \u0026 parameters)\n{\n    string plantMatStr = \"\";\n    std::vector\u003cselectability\u003e plantSelections;\n    set\u003cstring\u003e plantNames;\n    bool deselect = false, exclude = false, treesonly = false, shrubsonly = false, all = false;\n\n    int count = 0;\n\n    plantSelections.resize(world-\u003eraws.plants.all.size());\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        plantSelections[i] = selectability::Unselected;\n    }\n    \n    bool anyPlantsSelected = false;\n\n    for (size_t i = 0; i \u003c parameters.size(); i++)\n    {\n        if(parameters[i] == \"help\" || parameters[i] == \"?\")\n            return CR_WRONG_USAGE;\n        else if(parameters[i] == \"-t\")\n            treesonly = true;\n        else if(parameters[i] == \"-s\")\n            shrubsonly = true;\n        else if(parameters[i] == \"-c\")\n            deselect = true;\n        else if(parameters[i] == \"-x\")\n            exclude = true;\n        else if(parameters[i] == \"-a\")\n            all = true;\n        else\n            plantNames.insert(parameters[i]);\n    }\n    if (treesonly \u0026\u0026 shrubsonly)\n    {\n        out.printerr(\"Cannot specify both -t and -s at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 exclude)\n    {\n        out.printerr(\"Cannot specify both -a and -x at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 plantNames.size())\n    {\n        out.printerr(\"Cannot specify -a along with plant IDs!\\n\");\n        return CR_WRONG_USAGE;\n    }\n\n    CoreSuspender suspend;\n\n    for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n    {\n        df::plant_raw *plant = world-\u003eraws.plants.all[i];\n        if (all)\n        {\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n        }\n         else if (plantNames.find(plant-\u003eid) != plantNames.end())\n        {\n            plantNames.erase(plant-\u003eid);\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n            switch (plantSelections[i])\n            {\n            case selectability::Grass:\n            {\n                out.printerr(\"%s is a Grass, and those can not be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n\n            case selectability::Nonselectable:\n            {\n                out.printerr(\"%s does not have any parts that can be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::OutOfSeason:\n            {\n                out.printerr(\"%s is out of season, with nothing that can be gathered now\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::Selectable:\n                break;\n\n            case selectability::Unselected:\n                break;  //  We won't get to this option\n            }\n        }\n    }\n    if (plantNames.size() \u003e 0)\n    {\n        out.printerr(\"Invalid plant ID(s):\");\n        for (set\u003cstring\u003e::const_iterator it = plantNames.begin(); it != plantNames.end(); it++)\n            out.printerr(\" %s\", it-\u003ec_str());\n        out.printerr(\"\\n\");\n        return CR_FAILURE;\n    }\n\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        if (plantSelections[i] == selectability::OutOfSeason ||\n            plantSelections[i] == selectability::Selectable)\n        {\n            anyPlantsSelected = true;\n            break;\n        }\n    }\n\n    if (!anyPlantsSelected)\n    {\n        out.print(\"Valid plant IDs:\\n\");\n        for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n        {\n            df::plant_raw *plant = world-\u003eraws.plants.all[i];\n//            switch (selectablePlant(out, plant))\n            switch (selectablePlant(plant))\n                {\n            case selectability::Grass:\n            case selectability::Nonselectable:\n                continue;\n\n            case selectability::OutOfSeason:\n            {\n                out.print(\"* (shrub) %s - %s is out of season\\n\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Selectable:\n            {\n                out.print(\"* (%s) %s - %s\\n\", plant-\u003eflags.is_set(plant_raw_flags::TREE) ? \"tree\" : \"shrub\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Unselected:  //  Should never get this alternative\n                break;\n            }\n        }\n        return CR_OK;\n    }\n\n    count = 0;\n    for (size_t i = 0; i \u003c world-\u003eplants.all.size(); i++)\n    {\n        const df::plant *plant = world-\u003eplants.all[i];\n        df::map_block *cur = Maps::getTileBlock(plant-\u003epos);\n        bool dirty = false;\n\n        int x = plant-\u003epos.x % 16;\n        int y = plant-\u003epos.y % 16;\n        if (plantSelections[plant-\u003ematerial] == selectability::OutOfSeason ||\n            plantSelections[plant-\u003ematerial] == selectability::Selectable)\n        {\n            if (exclude ||\n                plantSelections[plant-\u003ematerial] == selectability::OutOfSeason)\n                continue;\n        }\n        else\n        {\n            if (!exclude)\n                continue;\n        }\n        df::tiletype_shape shape = tileShape(cur-\u003etiletype[x][y]);\n        df::tiletype_material material = tileMaterial(cur-\u003etiletype[x][y]);\n        df::tiletype_special special = tileSpecial(cur-\u003etiletype[x][y]);\n        if (plant-\u003eflags.bits.is_shrub \u0026\u0026 (treesonly || !(shape == tiletype_shape::SHRUB \u0026\u0026 special != tiletype_special::DEAD)))\n            continue;\n        if (!plant-\u003eflags.bits.is_shrub \u0026\u0026 (shrubsonly || !(material == tiletype_material::TREE)))\n            continue;\n        if (cur-\u003edesignation[x][y].bits.hidden)\n            continue;\n        if (deselect \u0026\u0026 Designations::unmarkPlant(plant))\n        {\n            ++count;\n        }\n        if (!deselect \u0026\u0026 Designations::markPlant(plant))\n        {\n            ++count;\n        }\n    }\n    if (count)\n        out.print(\"Updated %d plant designations.\\n\", count);\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_init ( color_ostream \u0026out, vector \u003cPluginCommand\u003e \u0026commands)\n{\n    commands.push_back(PluginCommand(\n        \"getplants\", \"Cut down trees or gather shrubs by ID\",\n        df_getplants, false,\n        \"  Specify the types of trees to cut down and/or shrubs to gather by their\\n\"\n        \"  plant IDs, separated by spaces.\\n\"\n        \"Options:\\n\"\n        \"  -t - Select trees only (exclude shrubs)\\n\"\n        \"  -s - Select shrubs only (exclude trees)\\n\"\n        \"  -c - Clear designations instead of setting them\\n\"\n        \"  -x - Apply selected action to all plants except those specified\\n\"\n        \"  -a - Select every type of plant (obeys -t/-s)\\n\"\n        \"Specifying both -t and -s will have no effect.\\n\"\n        \"If no plant IDs are specified, all valid plant IDs will be listed.\\n\"\n    ));\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_shutdown ( color_ostream \u0026out )\n{\n    return CR_OK;\n}\n```\n\nEdit 2:\nI ran a script checking the item_type of all growths, and SEEDS does indeed exist. However, all of them are nuts (Macadamia, Almond, Ginko, Hazel, Pecan, Walnut, Oak, Candlenut), and so won't apply to any vanilla shrubs (but could apply to modded raws, of course, and thus ought to be checked).\n\nIt seems the bug regarding beans etc. is number 0006940 (a rare instance where a bug tracker search actually found things related to the search term [\"bean\" in this case] instead of page after page of completely unrelated reports that don't seem to contain the search term anywhere). Beans seem to not work for farming either, if I read the report correctly.","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1578670604,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzNTgzODM2Nw=="},"target":"fd31bbafa4cab2a61ded2b978fe85731051b1267d31897bc8744c3b480a83b49","message":"Thanks for the feedback, quietust.\n\nI usually assume the need for a change of a name to be caused by DF changing the use, rather than the person originally naming it having made an error. That's why I try to use the term \"obsolete\" rather than \"incorrect\".\n\nEdit:\nI probably misunderstand quietust, because checking a growth's item_type for SEEDS causes the checks to fail to find FRUIT/POD containing edible seeds (all growths seem to be of the item_type PLANT_GROWTH in the small sample I've looked at).\nThe trouble plants seem to be:\nBAMBARA_GROUND_NUT, STRING_BEAN, BROAD_BEAN, LENTIL, MUNG_BEAN, PEA, PEANUT, RED_BEAN, SOYBEAN, and URAD_BEAN, (I have missed some in that list, e.g. COWPEA), i.e. the ones that have inedible growths containing edible seeds. I recall having heard of trouble with collection of those kinds of plants, but as you can't make booze out of them I haven't thought about it further, so I don't know if DF can't collect them, can't designate them (but collect them once designated by DFHack), or if there was something else entirely.\nThus, at the moment my issue seems to be to fulfill the \"at least one time-valid plant growth produces SEEDS items whose material is EDIBLE_RAW or EDIBLE_COOKED\" criterion. I can find the growth, but its material isn't edible, nor does it refer to any seed material. The only lead I have is the \u003cgrowth\u003e.behavior.has_seed flag, but without any indication of how to get the seed (without iterating over \u003eplant_raw\u003e.material) and its material.\n(Interestingly enough, the strawberry fruit growth doesn't have its behavior.has_seed flag set, so it doesn't seem to indicate whether the growth contains seeds, but possibly whether it contains edible ones).\n\nHm, changing the code to use the .has_seed flag and get the material from \u003cplant_raw\u003e.material_defs.type_seed/idx_seed allows the code to designate the trouble shrubs while DF doesn't. However, observing a plant gatherer trying to pick such a plant up shows nothing in the inventory and the plant remaining, and running \"getplant URAD_BEAN\" again after it was \"picked up\" designated it again, a plant gatherer went there, and failed to pick anything so it doesn't actually work. The issue with beans I seem to recall _might_ be that you can grow them (and get seeds through harvesting) assuming you get seeds from the outside, but can't gather them.\n\nI've ended up with this code (it ignores the edible seed criterion that doesn't seem to work, and adds a little feedback about things that are out of season, since we need to check the time internally anyway):\n```\n// (un)designate matching plants for gathering/cutting\n\n#include \u003cset\u003e\n\n#include \"Core.h\"\n#include \"Console.h\"\n#include \"Export.h\"\n#include \"PluginManager.h\"\n#include \"DataDefs.h\"\n#include \"TileTypes.h\"\n\n#include \"df/map_block.h\"\n#include \"df/plant.h\"\n#include \"df/plant_growth.h\"\n#include \"df/plant_raw.h\"\n#include \"df/tile_dig_designation.h\"\n#include \"df/world.h\"\n\n#include \"modules/Designations.h\"\n#include \"modules/Maps.h\"\n#include \"modules/Materials.h\"\n\nusing std::string;\nusing std::vector;\nusing std::set;\n\nusing namespace DFHack;\nusing namespace df::enums;\n\nDFHACK_PLUGIN(\"getplants\");\nREQUIRE_GLOBAL(world);\nREQUIRE_GLOBAL(cur_year_tick);\n\nenum class selectability {\n    Selectable,\n    Grass,\n    Nonselectable,\n    OutOfSeason,\n    Unselected\n};\n\n//selectability selectablePlant(color_ostream \u0026out, const df::plant_raw *plant)\nselectability selectablePlant(const df::plant_raw *plant)\n{\n    const DFHack::MaterialInfo basic_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_basic_mat, plant-\u003ematerial_defs.idx_basic_mat);\n    bool outOfSeason = false;\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::TREE))\n    {\n//        out.print(\"%s is a selectable tree\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n    else if (plant-\u003eflags.is_set(plant_raw_flags::GRASS))\n    {\n//        out.print(\"%s is a non selectable Grass\\n\", plant-\u003eid.c_str());\n        return selectability::Grass;\n    }\n\n    if (basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n        basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n    {\n//        out.print(\"%s is a edible\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::THREAD) ||\n        plant-\u003eflags.is_set(plant_raw_flags::MILL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_VIAL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_BARREL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_STILL_VIAL))\n    {\n//        out.print(\"%s is thread/mill/extract\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (basic_mat.material-\u003ereaction_product.id.size() \u003e 0 ||\n        basic_mat.material-\u003ereaction_class.size() \u003e 0)\n    {\n//        out.print(\"%s has a reaction\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    for (auto i = 0; i \u003c plant-\u003egrowths.size(); i++)\n    {\n        if (plant-\u003egrowths[i]-\u003eitem_type == df::item_type::PLANT_GROWTH)\n        {\n            const DFHack::MaterialInfo growth_mat = DFHack::MaterialInfo(plant-\u003egrowths[i]-\u003emat_type, plant-\u003egrowths[i]-\u003emat_index);\n            if (growth_mat.material-\u003eflags.is_set(material_flags::STOCKPILE_PLANT_GROWTH))\n            {\n                if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                    (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                        *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                {\n//                    out.print(\"%s has a stockpile growth\\n\", plant-\u003eid.c_str());\n                    return selectability::Selectable;\n                }\n                else\n                {\n                    outOfSeason = true;\n                }\n            }\n/*            else if (plant-\u003egrowths[i]-\u003ebehavior.bits.has_seed)  //  This code designates beans, etc. when DF doesn't, but plant gatherers still fail to collect anything.\n            {\n                const DFHack::MaterialInfo seed_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_seed, plant-\u003ematerial_defs.idx_seed);\n\n                if (seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n                    seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n                {\n                    if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                        (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                            *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                    {\n                        return selectability::Selectable;\n                    }\n                    else\n                    {\n                        outOfSeason = true;\n                    }\n                }\n            }  */          \n        }\n    }\n\n    if (outOfSeason)\n    {\n//        out.print(\"%s has an out of season growth\\n\", plant-\u003eid.c_str());\n        return selectability::OutOfSeason;\n    }\n    else\n    {\n//        out.printerr(\"%s cannot be gathered\\n\", plant-\u003eid.c_str());\n        return selectability::Nonselectable;\n    }\n}\n\ncommand_result df_getplants (color_ostream \u0026out, vector \u003cstring\u003e \u0026 parameters)\n{\n    string plantMatStr = \"\";\n    std::vector\u003cselectability\u003e plantSelections;\n    set\u003cstring\u003e plantNames;\n    bool deselect = false, exclude = false, treesonly = false, shrubsonly = false, all = false;\n\n    int count = 0;\n\n    plantSelections.resize(world-\u003eraws.plants.all.size());\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        plantSelections[i] = selectability::Unselected;\n    }\n    \n    bool anyPlantsSelected = false;\n\n    for (size_t i = 0; i \u003c parameters.size(); i++)\n    {\n        if(parameters[i] == \"help\" || parameters[i] == \"?\")\n            return CR_WRONG_USAGE;\n        else if(parameters[i] == \"-t\")\n            treesonly = true;\n        else if(parameters[i] == \"-s\")\n            shrubsonly = true;\n        else if(parameters[i] == \"-c\")\n            deselect = true;\n        else if(parameters[i] == \"-x\")\n            exclude = true;\n        else if(parameters[i] == \"-a\")\n            all = true;\n        else\n            plantNames.insert(parameters[i]);\n    }\n    if (treesonly \u0026\u0026 shrubsonly)\n    {\n        out.printerr(\"Cannot specify both -t and -s at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 exclude)\n    {\n        out.printerr(\"Cannot specify both -a and -x at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 plantNames.size())\n    {\n        out.printerr(\"Cannot specify -a along with plant IDs!\\n\");\n        return CR_WRONG_USAGE;\n    }\n\n    CoreSuspender suspend;\n\n    for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n    {\n        df::plant_raw *plant = world-\u003eraws.plants.all[i];\n        if (all)\n        {\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n        }\n         else if (plantNames.find(plant-\u003eid) != plantNames.end())\n        {\n            plantNames.erase(plant-\u003eid);\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n            switch (plantSelections[i])\n            {\n            case selectability::Grass:\n            {\n                out.printerr(\"%s is a Grass, and those can not be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n\n            case selectability::Nonselectable:\n            {\n                out.printerr(\"%s does not have any parts that can be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::OutOfSeason:\n            {\n                out.printerr(\"%s is out of season, with nothing that can be gathered now\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::Selectable:\n                break;\n\n            case selectability::Unselected:\n                break;  //  We won't get to this option\n            }\n        }\n    }\n    if (plantNames.size() \u003e 0)\n    {\n        out.printerr(\"Invalid plant ID(s):\");\n        for (set\u003cstring\u003e::const_iterator it = plantNames.begin(); it != plantNames.end(); it++)\n            out.printerr(\" %s\", it-\u003ec_str());\n        out.printerr(\"\\n\");\n        return CR_FAILURE;\n    }\n\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        if (plantSelections[i] == selectability::OutOfSeason ||\n            plantSelections[i] == selectability::Selectable)\n        {\n            anyPlantsSelected = true;\n            break;\n        }\n    }\n\n    if (!anyPlantsSelected)\n    {\n        out.print(\"Valid plant IDs:\\n\");\n        for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n        {\n            df::plant_raw *plant = world-\u003eraws.plants.all[i];\n//            switch (selectablePlant(out, plant))\n            switch (selectablePlant(plant))\n                {\n            case selectability::Grass:\n            case selectability::Nonselectable:\n                continue;\n\n            case selectability::OutOfSeason:\n            {\n                out.print(\"* (shrub) %s - %s is out of season\\n\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Selectable:\n            {\n                out.print(\"* (%s) %s - %s\\n\", plant-\u003eflags.is_set(plant_raw_flags::TREE) ? \"tree\" : \"shrub\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Unselected:  //  Should never get this alternative\n                break;\n            }\n        }\n        return CR_OK;\n    }\n\n    count = 0;\n    for (size_t i = 0; i \u003c world-\u003eplants.all.size(); i++)\n    {\n        const df::plant *plant = world-\u003eplants.all[i];\n        df::map_block *cur = Maps::getTileBlock(plant-\u003epos);\n        bool dirty = false;\n\n        int x = plant-\u003epos.x % 16;\n        int y = plant-\u003epos.y % 16;\n        if (plantSelections[plant-\u003ematerial] == selectability::OutOfSeason ||\n            plantSelections[plant-\u003ematerial] == selectability::Selectable)\n        {\n            if (exclude ||\n                plantSelections[plant-\u003ematerial] == selectability::OutOfSeason)\n                continue;\n        }\n        else\n        {\n            if (!exclude)\n                continue;\n        }\n        df::tiletype_shape shape = tileShape(cur-\u003etiletype[x][y]);\n        df::tiletype_material material = tileMaterial(cur-\u003etiletype[x][y]);\n        df::tiletype_special special = tileSpecial(cur-\u003etiletype[x][y]);\n        if (plant-\u003eflags.bits.is_shrub \u0026\u0026 (treesonly || !(shape == tiletype_shape::SHRUB \u0026\u0026 special != tiletype_special::DEAD)))\n            continue;\n        if (!plant-\u003eflags.bits.is_shrub \u0026\u0026 (shrubsonly || !(material == tiletype_material::TREE)))\n            continue;\n        if (cur-\u003edesignation[x][y].bits.hidden)\n            continue;\n        if (deselect \u0026\u0026 Designations::unmarkPlant(plant))\n        {\n            ++count;\n        }\n        if (!deselect \u0026\u0026 Designations::markPlant(plant))\n        {\n            ++count;\n        }\n    }\n    if (count)\n        out.print(\"Updated %d plant designations.\\n\", count);\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_init ( color_ostream \u0026out, vector \u003cPluginCommand\u003e \u0026commands)\n{\n    commands.push_back(PluginCommand(\n        \"getplants\", \"Cut down trees or gather shrubs by ID\",\n        df_getplants, false,\n        \"  Specify the types of trees to cut down and/or shrubs to gather by their\\n\"\n        \"  plant IDs, separated by spaces.\\n\"\n        \"Options:\\n\"\n        \"  -t - Select trees only (exclude shrubs)\\n\"\n        \"  -s - Select shrubs only (exclude trees)\\n\"\n        \"  -c - Clear designations instead of setting them\\n\"\n        \"  -x - Apply selected action to all plants except those specified\\n\"\n        \"  -a - Select every type of plant (obeys -t/-s)\\n\"\n        \"Specifying both -t and -s will have no effect.\\n\"\n        \"If no plant IDs are specified, all valid plant IDs will be listed.\\n\"\n    ));\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_shutdown ( color_ostream \u0026out )\n{\n    return CR_OK;\n}\n```\n\nEdit 2:\nI ran a script checking the item_type of all growths, and SEEDS does indeed exist. However, all of them are nuts (Macadamia, Almond, Ginko, Hazel, Pecan, Walnut, Oak, Candlenut), and so won't apply to any vanilla shrubs (but could apply to modded raws, of course, and thus ought to be checked).\n\nIt seems the bug regarding beans etc. is number 0006940 (a rare instance where a bug tracker search actually found things related to the search term [\"bean\" in this case] instead of page after page of completely unrelated reports that don't seem to contain the search term anywhere). Beans seem to not work for farming either, if I read the report correctly.\n\nEdit 3:\nWell, I just found that DF does know to distinguish present growths from absent ones. DF refrained from designating one instance of Bitter Melon Vines, while designating all other Bitter Melons (at least one of which has Bitter Melon Leaves and Bitter Melon in addition to the Vines).\nThus, another thing to look for.\n\nI've also tried to figure out how DF determines where seeds are supposed to come from (i.e. which plant part has to be collected in order to get seeds from it). Most plants have SEED_MAT reactions, some (trees) have growths of the item_type SEEDS, and some have growths with behavior.has_seed, but then there is a bunch that has none of those, and at least some of those can't get the seeds from the STRUCTURAL_MAT, as it's inedible. The trouble shrubs (a number of trees also end up in this category), regardless of which parts are edible, are CABBAGE, CELERY, CHICORY, GARDEN_CRESS, GARLIC, LEEK, LETTUCE, ONION, RHUBARB, SPINACH, TARO, LESSER_YAM, LONG_YAM, PURPLE_YAM, MUSHROOM_CUP_DIMPLE, WEED_BLADE, and ROOT_HIDE. Some of these would need to get the seeds from their underground parts, as the above ground ones can't be used.\nThe reason I'm looking at this is to try to add a \"-f\" switch (\"farming\", as \"-s\" is already taken) to specifically designate shrubs to get seeds for farming.","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1579354986,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMzOTk3MjkwNg=="},"target":"fd31bbafa4cab2a61ded2b978fe85731051b1267d31897bc8744c3b480a83b49","message":"Thanks for the feedback, quietust.\n\nI usually assume the need for a change of a name to be caused by DF changing the use, rather than the person originally naming it having made an error. That's why I try to use the term \"obsolete\" rather than \"incorrect\".\n\nEdit:\nI probably misunderstand quietust, because checking a growth's item_type for SEEDS causes the checks to fail to find FRUIT/POD containing edible seeds (all growths seem to be of the item_type PLANT_GROWTH in the small sample I've looked at).\nThe trouble plants seem to be:\nBAMBARA_GROUND_NUT, STRING_BEAN, BROAD_BEAN, LENTIL, MUNG_BEAN, PEA, PEANUT, RED_BEAN, SOYBEAN, and URAD_BEAN, (I have missed some in that list, e.g. COWPEA), i.e. the ones that have inedible growths containing edible seeds. I recall having heard of trouble with collection of those kinds of plants, but as you can't make booze out of them I haven't thought about it further, so I don't know if DF can't collect them, can't designate them (but collect them once designated by DFHack), or if there was something else entirely.\nThus, at the moment my issue seems to be to fulfill the \"at least one time-valid plant growth produces SEEDS items whose material is EDIBLE_RAW or EDIBLE_COOKED\" criterion. I can find the growth, but its material isn't edible, nor does it refer to any seed material. The only lead I have is the \u003cgrowth\u003e.behavior.has_seed flag, but without any indication of how to get the seed (without iterating over \u003eplant_raw\u003e.material) and its material.\n(Interestingly enough, the strawberry fruit growth doesn't have its behavior.has_seed flag set, so it doesn't seem to indicate whether the growth contains seeds, but possibly whether it contains edible ones).\n\nHm, changing the code to use the .has_seed flag and get the material from \u003cplant_raw\u003e.material_defs.type_seed/idx_seed allows the code to designate the trouble shrubs while DF doesn't. However, observing a plant gatherer trying to pick such a plant up shows nothing in the inventory and the plant remaining, and running \"getplant URAD_BEAN\" again after it was \"picked up\" designated it again, a plant gatherer went there, and failed to pick anything so it doesn't actually work. The issue with beans I seem to recall _might_ be that you can grow them (and get seeds through harvesting) assuming you get seeds from the outside, but can't gather them.\n\nI've ended up with this code (it ignores the edible seed criterion that doesn't seem to work, and adds a little feedback about things that are out of season, since we need to check the time internally anyway):\n```\n// (un)designate matching plants for gathering/cutting\n\n#include \u003cset\u003e\n\n#include \"Core.h\"\n#include \"Console.h\"\n#include \"Export.h\"\n#include \"PluginManager.h\"\n#include \"DataDefs.h\"\n#include \"TileTypes.h\"\n\n#include \"df/map_block.h\"\n#include \"df/plant.h\"\n#include \"df/plant_growth.h\"\n#include \"df/plant_raw.h\"\n#include \"df/tile_dig_designation.h\"\n#include \"df/world.h\"\n\n#include \"modules/Designations.h\"\n#include \"modules/Maps.h\"\n#include \"modules/Materials.h\"\n\nusing std::string;\nusing std::vector;\nusing std::set;\n\nusing namespace DFHack;\nusing namespace df::enums;\n\nDFHACK_PLUGIN(\"getplants\");\nREQUIRE_GLOBAL(world);\nREQUIRE_GLOBAL(cur_year_tick);\n\nenum class selectability {\n    Selectable,\n    Grass,\n    Nonselectable,\n    OutOfSeason,\n    Unselected\n};\n\n//selectability selectablePlant(color_ostream \u0026out, const df::plant_raw *plant)\nselectability selectablePlant(const df::plant_raw *plant)\n{\n    const DFHack::MaterialInfo basic_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_basic_mat, plant-\u003ematerial_defs.idx_basic_mat);\n    bool outOfSeason = false;\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::TREE))\n    {\n//        out.print(\"%s is a selectable tree\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n    else if (plant-\u003eflags.is_set(plant_raw_flags::GRASS))\n    {\n//        out.print(\"%s is a non selectable Grass\\n\", plant-\u003eid.c_str());\n        return selectability::Grass;\n    }\n\n    if (basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n        basic_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n    {\n//        out.print(\"%s is a edible\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (plant-\u003eflags.is_set(plant_raw_flags::THREAD) ||\n        plant-\u003eflags.is_set(plant_raw_flags::MILL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_VIAL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_BARREL) ||\n        plant-\u003eflags.is_set(plant_raw_flags::EXTRACT_STILL_VIAL))\n    {\n//        out.print(\"%s is thread/mill/extract\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    if (basic_mat.material-\u003ereaction_product.id.size() \u003e 0 ||\n        basic_mat.material-\u003ereaction_class.size() \u003e 0)\n    {\n//        out.print(\"%s has a reaction\\n\", plant-\u003eid.c_str());\n        return selectability::Selectable;\n    }\n\n    for (auto i = 0; i \u003c plant-\u003egrowths.size(); i++)\n    {\n        if (plant-\u003egrowths[i]-\u003eitem_type == df::item_type::PLANT_GROWTH)\n        {\n            const DFHack::MaterialInfo growth_mat = DFHack::MaterialInfo(plant-\u003egrowths[i]-\u003emat_type, plant-\u003egrowths[i]-\u003emat_index);\n            if (growth_mat.material-\u003eflags.is_set(material_flags::STOCKPILE_PLANT_GROWTH))\n            {\n                if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                    (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                        *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                {\n//                    out.print(\"%s has a stockpile growth\\n\", plant-\u003eid.c_str());\n                    return selectability::Selectable;\n                }\n                else\n                {\n                    outOfSeason = true;\n                }\n            }\n/*            else if (plant-\u003egrowths[i]-\u003ebehavior.bits.has_seed)  //  This code designates beans, etc. when DF doesn't, but plant gatherers still fail to collect anything.\n            {\n                const DFHack::MaterialInfo seed_mat = DFHack::MaterialInfo(plant-\u003ematerial_defs.type_seed, plant-\u003ematerial_defs.idx_seed);\n\n                if (seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_RAW) ||\n                    seed_mat.material-\u003eflags.is_set(material_flags::EDIBLE_COOKED))\n                {\n                    if (*cur_year_tick \u003e= plant-\u003egrowths[i]-\u003etiming_1 \u0026\u0026\n                        (plant-\u003egrowths[i]-\u003etiming_2 == -1 ||\n                            *cur_year_tick \u003c= plant-\u003egrowths[i]-\u003etiming_2))\n                    {\n                        return selectability::Selectable;\n                    }\n                    else\n                    {\n                        outOfSeason = true;\n                    }\n                }\n            }  */          \n        }\n    }\n\n    if (outOfSeason)\n    {\n//        out.print(\"%s has an out of season growth\\n\", plant-\u003eid.c_str());\n        return selectability::OutOfSeason;\n    }\n    else\n    {\n//        out.printerr(\"%s cannot be gathered\\n\", plant-\u003eid.c_str());\n        return selectability::Nonselectable;\n    }\n}\n\ncommand_result df_getplants (color_ostream \u0026out, vector \u003cstring\u003e \u0026 parameters)\n{\n    string plantMatStr = \"\";\n    std::vector\u003cselectability\u003e plantSelections;\n    set\u003cstring\u003e plantNames;\n    bool deselect = false, exclude = false, treesonly = false, shrubsonly = false, all = false;\n\n    int count = 0;\n\n    plantSelections.resize(world-\u003eraws.plants.all.size());\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        plantSelections[i] = selectability::Unselected;\n    }\n    \n    bool anyPlantsSelected = false;\n\n    for (size_t i = 0; i \u003c parameters.size(); i++)\n    {\n        if(parameters[i] == \"help\" || parameters[i] == \"?\")\n            return CR_WRONG_USAGE;\n        else if(parameters[i] == \"-t\")\n            treesonly = true;\n        else if(parameters[i] == \"-s\")\n            shrubsonly = true;\n        else if(parameters[i] == \"-c\")\n            deselect = true;\n        else if(parameters[i] == \"-x\")\n            exclude = true;\n        else if(parameters[i] == \"-a\")\n            all = true;\n        else\n            plantNames.insert(parameters[i]);\n    }\n    if (treesonly \u0026\u0026 shrubsonly)\n    {\n        out.printerr(\"Cannot specify both -t and -s at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 exclude)\n    {\n        out.printerr(\"Cannot specify both -a and -x at the same time!\\n\");\n        return CR_WRONG_USAGE;\n    }\n    if (all \u0026\u0026 plantNames.size())\n    {\n        out.printerr(\"Cannot specify -a along with plant IDs!\\n\");\n        return CR_WRONG_USAGE;\n    }\n\n    CoreSuspender suspend;\n\n    for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n    {\n        df::plant_raw *plant = world-\u003eraws.plants.all[i];\n        if (all)\n        {\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n        }\n         else if (plantNames.find(plant-\u003eid) != plantNames.end())\n        {\n            plantNames.erase(plant-\u003eid);\n//            plantSelections[i] = selectablePlant(out, plant);\n            plantSelections[i] = selectablePlant(plant);\n            switch (plantSelections[i])\n            {\n            case selectability::Grass:\n            {\n                out.printerr(\"%s is a Grass, and those can not be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n\n            case selectability::Nonselectable:\n            {\n                out.printerr(\"%s does not have any parts that can be gathered\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::OutOfSeason:\n            {\n                out.printerr(\"%s is out of season, with nothing that can be gathered now\\n\", plant-\u003eid.c_str());\n                break;\n            }\n            case selectability::Selectable:\n                break;\n\n            case selectability::Unselected:\n                break;  //  We won't get to this option\n            }\n        }\n    }\n    if (plantNames.size() \u003e 0)\n    {\n        out.printerr(\"Invalid plant ID(s):\");\n        for (set\u003cstring\u003e::const_iterator it = plantNames.begin(); it != plantNames.end(); it++)\n            out.printerr(\" %s\", it-\u003ec_str());\n        out.printerr(\"\\n\");\n        return CR_FAILURE;\n    }\n\n    for (auto i = 0; i \u003c plantSelections.size(); i++)\n    {\n        if (plantSelections[i] == selectability::OutOfSeason ||\n            plantSelections[i] == selectability::Selectable)\n        {\n            anyPlantsSelected = true;\n            break;\n        }\n    }\n\n    if (!anyPlantsSelected)\n    {\n        out.print(\"Valid plant IDs:\\n\");\n        for (size_t i = 0; i \u003c world-\u003eraws.plants.all.size(); i++)\n        {\n            df::plant_raw *plant = world-\u003eraws.plants.all[i];\n//            switch (selectablePlant(out, plant))\n            switch (selectablePlant(plant))\n                {\n            case selectability::Grass:\n            case selectability::Nonselectable:\n                continue;\n\n            case selectability::OutOfSeason:\n            {\n                out.print(\"* (shrub) %s - %s is out of season\\n\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Selectable:\n            {\n                out.print(\"* (%s) %s - %s\\n\", plant-\u003eflags.is_set(plant_raw_flags::TREE) ? \"tree\" : \"shrub\", plant-\u003eid.c_str(), plant-\u003ename.c_str());\n                break;\n            }\n\n            case selectability::Unselected:  //  Should never get this alternative\n                break;\n            }\n        }\n        return CR_OK;\n    }\n\n    count = 0;\n    for (size_t i = 0; i \u003c world-\u003eplants.all.size(); i++)\n    {\n        const df::plant *plant = world-\u003eplants.all[i];\n        df::map_block *cur = Maps::getTileBlock(plant-\u003epos);\n        bool dirty = false;\n\n        int x = plant-\u003epos.x % 16;\n        int y = plant-\u003epos.y % 16;\n        if (plantSelections[plant-\u003ematerial] == selectability::OutOfSeason ||\n            plantSelections[plant-\u003ematerial] == selectability::Selectable)\n        {\n            if (exclude ||\n                plantSelections[plant-\u003ematerial] == selectability::OutOfSeason)\n                continue;\n        }\n        else\n        {\n            if (!exclude)\n                continue;\n        }\n        df::tiletype_shape shape = tileShape(cur-\u003etiletype[x][y]);\n        df::tiletype_material material = tileMaterial(cur-\u003etiletype[x][y]);\n        df::tiletype_special special = tileSpecial(cur-\u003etiletype[x][y]);\n        if (plant-\u003eflags.bits.is_shrub \u0026\u0026 (treesonly || !(shape == tiletype_shape::SHRUB \u0026\u0026 special != tiletype_special::DEAD)))\n            continue;\n        if (!plant-\u003eflags.bits.is_shrub \u0026\u0026 (shrubsonly || !(material == tiletype_material::TREE)))\n            continue;\n        if (cur-\u003edesignation[x][y].bits.hidden)\n            continue;\n        if (deselect \u0026\u0026 Designations::unmarkPlant(plant))\n        {\n            ++count;\n        }\n        if (!deselect \u0026\u0026 Designations::markPlant(plant))\n        {\n            ++count;\n        }\n    }\n    if (count)\n        out.print(\"Updated %d plant designations.\\n\", count);\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_init ( color_ostream \u0026out, vector \u003cPluginCommand\u003e \u0026commands)\n{\n    commands.push_back(PluginCommand(\n        \"getplants\", \"Cut down trees or gather shrubs by ID\",\n        df_getplants, false,\n        \"  Specify the types of trees to cut down and/or shrubs to gather by their\\n\"\n        \"  plant IDs, separated by spaces.\\n\"\n        \"Options:\\n\"\n        \"  -t - Select trees only (exclude shrubs)\\n\"\n        \"  -s - Select shrubs only (exclude trees)\\n\"\n        \"  -c - Clear designations instead of setting them\\n\"\n        \"  -x - Apply selected action to all plants except those specified\\n\"\n        \"  -a - Select every type of plant (obeys -t/-s)\\n\"\n        \"Specifying both -t and -s will have no effect.\\n\"\n        \"If no plant IDs are specified, all valid plant IDs will be listed.\\n\"\n    ));\n    return CR_OK;\n}\n\nDFhackCExport command_result plugin_shutdown ( color_ostream \u0026out )\n{\n    return CR_OK;\n}\n```\n\nEdit 2:\nI ran a script checking the item_type of all growths, and SEEDS does indeed exist. However, all of them are nuts (Macadamia, Almond, Ginko, Hazel, Pecan, Walnut, Oak, Candlenut), and so won't apply to any vanilla shrubs (but could apply to modded raws, of course, and thus ought to be checked).\n\nIt seems the bug regarding beans etc. is number 0006940 (a rare instance where a bug tracker search actually found things related to the search term [\"bean\" in this case] instead of page after page of completely unrelated reports that don't seem to contain the search term anywhere). Beans seem to not work for farming either, if I read the report correctly.\n\nEdit 3:\nWell, I just found that DF does know to distinguish present growths from absent ones. DF refrained from designating one instance of Bitter Melon Vines, while designating all other Bitter Melons (at least one of which has Bitter Melon Leaves and Bitter Melon in addition to the Vines).\nThus, another thing to look for.\n\nI've also tried to figure out how DF determines where seeds are supposed to come from (i.e. which plant part has to be collected in order to get seeds from it). Most plants have SEED_MAT reactions, some (trees) have growths of the item_type SEEDS, and some have growths with behavior.has_seed, but then there is a bunch that has none of those, and at least some of those can't get the seeds from the STRUCTURAL_MAT, as it's inedible. The trouble shrubs (a number of trees also end up in this category), regardless of which parts are edible, are CABBAGE, CELERY, CHICORY, GARDEN_CRESS, GARLIC, LEEK, LETTUCE, ONION, RHUBARB, SPINACH, TARO, LESSER_YAM, LONG_YAM, PURPLE_YAM, MUSHROOM_CUP_DIMPLE, WEED_BLADE, and ROOT_HIDE. Some of these would need to get the seeds from their underground parts, as the above ground ones can't be used.\nThe reason I'm looking at this is to try to add a \"-f\" switch (\"farming\", as \"-s\" is already taken) to specifically designate shrubs to get seeds for farming.\n\nEdit 4:\nI've looked at LETTUCE, which produces both an edible structure and an edible leaf, and seen that dorfs eating the leaves (in an embark) do not leave seeds behind, while those who eat the structure part do. I moved on to SPINACH, and found that the leaf (the only edible part) does not produce any seed. Thus, it seems it shouldn't be possible to grow those except from imported seeds. Most forms of Yam is edible only when cooked, so, again, it seems they should be possible to grow only from imported seeds.\nMy conclusion is that the trouble group above implicitly produces seeds from their structural part, and if there is no valid process (milling, brewing, etc.) for that part and it can't be eaten raw, you can't grow it sustainably.\n\nI've made no progress regarding detection of growths. Tile sets (Phoebus, in my case) can display that a tree has been picked partially, and DF can show that there's fallen fruit on the ground, but I haven't managed to find any map or plant data that shows any of: growths being present, picked, or dropped.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1584967229,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYwMjU2NTg1Ng==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-602565856"},"message":"@quietust Does your ability to look at the DF code allow you to figure out where we might need to look for growths that can be picked/gathered? The plant raws provides the timing for when growths may be present, but after they're picked the plants they grew on still remain if the plants themselves (the structure part) are not useful (e.g. bitter melon), DF is clearly capable of displaying the fruit/nuts on trees, removing them from display as they're picked, and DF also refuses to designate already picked shrubs for picking, so the info is clearly there, somewhere.\nI suspect the growths are stored in some unmapped structure, although it's obviously not possible to rule out a failure on my part to find something \"hiding\" in plain sight.","files":null},{"type":3,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1590708206,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYzNTY2ODEzMw==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-635668133"},"message":"In version 0.47.04 on 64-bit Windows, the function for designating Shrub tiles for plant gathering is located at address 0x140DE87C0. My analysis above is based entirely on that function, but I omitted some details that I wasn't able to figure out at the time - specifically, how the game decides that growths are \"time-valid\".\n\nThe time validity is based on cur_year_tick plus/minus a *random* value (whose seed is based on the X and Y coordinates). I'm not exactly certain about the math involved, but that particular code is at 0x140DE89D1 if you want to try to analyze it in IDA or Ghidra.\n\nThere's another check I previously overlooked that involves records inside `world.world_data.object_data`, specifically the lists `unk_c0`/`unk_d0`/`unk_e0` (all int16, likely containing X/Y/Z coordinates) and `unk_f0`/`unk_100`/`unk_110` (all int32, with the 2nd being related to growth Density and the 3rd being a Year). These could very well be how it keeps track of which tiles have been harvested.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1590767738,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYzNTgxNDA0Ng==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-635814046"},"message":"Thanks, quietust. I'll try to see if I can get anything useful out of the structures you've pointed out. object_data is currently a dark corner of the structures, so anything hiding there would be hard to find without this kind of hint.\n\nI'll most likely not delve into code analysis, though, but it's definitely useful to know there is randomness involved (which is visible in game play, as you can see that trees in particular change different tiles at different times over a comparatively short period.","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1590767738,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzc1NTIwOTA4"},"target":"bf8cab44098c9204dbf2519c3f0ec91aeb56d1f6eb31f59fe586f7a2acca2552","message":"Thanks, quietust. I'll try to see if I can get anything useful out of the structures you've pointed out. object_data is currently a dark corner of the structures, so anything hiding there would be hard to find without this kind of hint.\n\nI'll most likely not delve into code analysis, though, but it's definitely useful to know there is randomness involved (which is visible in game play, as you can see that trees in particular change different tiles at different times over a comparatively short period).\n\nEdit:\nIt looks like the Id field is the world MLT coordinates of an MLT, unk_c0/unk_d0 the x/y coordinates within that tile, with unk_e0 being some weird coordinate with 100 = surface (on my flat embark anyway), and 101/102 being up in trees (the cursor z coordinates stop at 48 or something like that, at the top of the air, so it's not the normal z coordinate). unk_f0 seems to be the subtype (or growth index, if you like). Picking a horned melon resulted in an entry, while a strawberry plant did not (in the first case the structure is left behind, while in the second the whole plant is taken).","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1590831637,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzc1NjQ0NTkw"},"target":"bf8cab44098c9204dbf2519c3f0ec91aeb56d1f6eb31f59fe586f7a2acca2552","message":"Thanks, quietust. I'll try to see if I can get anything useful out of the structures you've pointed out. object_data is currently a dark corner of the structures, so anything hiding there would be hard to find without this kind of hint.\n\nI'll most likely not delve into code analysis, though, but it's definitely useful to know there is randomness involved (which is visible in game play, as you can see that trees in particular change different tiles at different times over a comparatively short period).\n\nEdit:\nIt looks like the Id field is the world MLT coordinates of an MLT, unk_c0/unk_d0 the x/y coordinates within that tile, with unk_e0 being some weird coordinate with 100 = surface (on my flat embark anyway), and 101/102 being up in trees (the cursor z coordinates stop at 48 or something like that, at the top of the air, so it's not the normal z coordinate). unk_f0 seems to be the subtype (or growth index, if you like). Picking a horned melon resulted in an entry, while a strawberry plant did not (in the first case the structure is left behind, while in the second the whole plant is taken).\n\nEdit2:\nI don't think the addresses specified are those within the DF exe, but rather addresses of a debugging session, as they're far too large to fit within the 19 MB of the exe, so they're probably of little use without a known base address.","files":null},{"type":3,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1591798019,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY0MjAzMzk1OQ==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-642033959"},"message":"Those addresses are indeed within the program's address space, assuming the default base address of 0x140000000.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1591798330,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY0MjAzNzAxMA==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-642037010"},"message":"Thanks. IDA did not display whatever base address it might be using, using a base of 0, and I'm not sure it remains the same between different OS'. At least the pointers end up pointing to vastly different address ranges between DF invocations, but that might be for other reasons.","files":null},{"type":3,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1593120327,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY0OTgyMjg5Mw==","github-url":"https://github.com/DFHack/dfhack/issues/1479#issuecomment-649822893"},"message":"I've done a bit more digging into the code for the \"random\" time variance on each tile, and it seems to be based on the following formula: `variance = ((435522653 - (((Y_coord + 3) * X_coord + 5) * ((Y_coord + 7) * Y_coord * 400181475 + 289700012))) \u0026 0x3FFFFFFF) % 2000`. As far as I can tell, the X and Y coordinates are relative to your entire embark, **not** the map_block in which the plants are located.\n\nNo, I don't know where any of those big numbers come from, but Ghidra managed to come up with the exact same equation so I'm pretty sure it's correct. That variance gets added to `cur_year_tick` (mod 403200), and the resulting timestamp is compared to the growth timing values to see if they're valid.","files":null},{"type":6,"author":{"id":"5221f59e75ea9db114593bbdfb180b7354aef9ed"},"timestamp":1593120327,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6MzgxNzI2ODQ3"},"target":"157c200d20d34ae4d98fe443a5b8217bfc1ac4b07f0eb05f828c21918b7d5b4d","message":"I've done a bit more digging into the code for the \"random\" time variance on each tile, and it seems to be based on the following formula: `variance = ((435522653 - (((Y_coord + 3) * X_coord + 5) * ((Y_coord + 7) * Y_coord * 400181475 + 289700012))) \u0026 0x3FFFFFFF) % 2000`.\n\nAs far as I can tell, the X and Y coordinates are relative to your entire embark, **not** the `map_block` in which the plants are located. No, I don't know how that works in Adventurer mode, where `map_block`s are continuously created and destroyed around you.\n\nAlso, no, I don't know where any of those big numbers came from or what they mean, but Ghidra managed to come up with the exact same equation so I'm pretty sure it's correct. That variance gets added to `cur_year_tick` (mod 403200), and the resulting timestamp is compared to the growth timing values to see if they're valid.","files":null},{"type":4,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1596693909,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MzYyNzUxNzM3NA=="},"status":2}]}