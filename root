{"version":1,"ops":[{"type":1,"author":{"id":"79a890393849d3d30e4552cb0fed0ecd393d9a9f"},"timestamp":1406208382,"metadata":{"github-id":"MDU6SXNzdWUzODYzMDY2OA==","github-url":"https://github.com/DFHack/dfhack/issues/271","origin":"github"},"title":"Ruby 1.9 - require an \".so\" file crashes (need to init stack?)","message":"While running on Windows, I noticed that requiring any of the .so files that typically exist in a Ruby installation (e.g., 'win32ole') causes dfhack to crash, hang, or the embedded ruby interpreter to throw a variety of low-level errors.\n\nDigging into ruby.cpp in dfhack, I noticed that RUBY_INIT_STACK is not called.  See http://stackoverflow.com/questions/6585610/why-does-this-code-not-work-on-ruby-1-9-but-works-on-ruby-1-8.  Apparently RUBY_INIT_STACK is a requirement when initializing an embedded version of at least Ruby 1.9 (not sure what is required for Ruby 2.0+).  Without it, I believe that certain features of the interpreter just blow up.\n\nI tested this (without recompiling DFHack) by creating an intermediate libruby DLL that exposed all of the Ruby DLL symbols that DFHack uses, but overrode ruby_sysinit to initially call RUBY_INIT_STACK.  I did this and ran a smoke test -- no longer crashes the interpreter, and thus far it has been stable.\n\nI realize that DFHack accesses the ruby DLL directly through its exported symbols and not by actually loading the ruby.h header file, which means you can't use the RUBY_INIT_STACK directly.  It appears to be a fairly simple macro though, so you might be able to import and call the one function it calls directly.  See ruby.h in any distribution of ruby.\n\nThanks,\n-Ben","files":null}]}