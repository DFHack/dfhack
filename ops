{"version":1,"ops":[{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1587886794,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYxOTUwMjE1MA==","github-url":"https://github.com/DFHack/dfhack/issues/1554#issuecomment-619502150"},"message":"Much of the exportlegends script is using a brute force approach, i.e. it reads all fields and generates a tag from the field name and inserts the contents of the field within those tag entries. This means the script doesn't \"know\" that the field is an enum, nor that -1 \"means\" don't know/don't care/...\n\nIt's possible for the script to detect that it's dealing with an enum and insert the enum value, but that causes the script to blow up every time it encounters an enum value that hasn't been mapped. It's probably possible to detect that an enum value isn't mapped and insert the numeric value instead, but that's not implemented currently (and ought to be made as a utility function in the script if used, rather than implemented separately in each location). I guess a utility function could check if the lower case converted enum string matches \"none\" and suppress generation in that case, but then it would have to be fed the tag string and generate both tags plus the data or nothing, and it would also have to be fed the number of indents to use.\nSuppressing tags when the value is -1 as a general measure will probably cause the script to behave incorrectly for a number of cases. I think there are enums where -1 is an actual value (together with -2 and -3), and you wouldn't want a Values element to be removed just because the value happens to be -1 (marginally negative, on a scale of -100 .. 100, I think).\n\nFor the parts that are hand coded to match the data it's dealing with, suppression of \"no info\" tags would be preferred (and I think it's done in some places). It can be noted that Toady has some cases of optional elements in his XML export (there are cases of combined start/end tags with no data where the tag name conveys the info).\n\nNote that this is my opinion, not any kind of \"official\" stand point.","files":null},{"type":6,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1587886794,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6MzY3ODMwNzY0"},"target":"443855b275999beb16aa26b5a1b9758a932a83903d7e8f84735612ba35d7ea7b","message":"Much of the exportlegends script is using a brute force approach, i.e. it reads all fields and generates a tag from the field name and inserts the contents of the field within those tag entries. This means the script doesn't \"know\" that the field is an enum, nor that -1 \"means\" don't know/don't care/...\n\nIt's possible for the script to detect that it's dealing with an enum and insert the enum value, but that causes the script to blow up every time it encounters an enum value that hasn't been mapped. It's probably possible to detect that an enum value isn't mapped and insert the numeric value instead, but that's not implemented currently (and ought to be made as a utility function in the script if used, rather than implemented separately in each location). I guess a utility function could check if the lower case converted enum string matches \"none\" and suppress generation in that case, but then it would have to be fed the tag string and generate both tags plus the data or nothing, and it would also have to be fed the number of indents to use.\nSuppressing tags when the value is -1 as a general measure will probably cause the script to behave incorrectly for a number of cases. I think there are enums where -1 is an actual value (together with -2 and -3), and you wouldn't want a Values element to be removed just because the value happens to be -1 (marginally negative, on a scale of -100 .. 100, I think).\n\nFor the parts that are hand coded to match the data it's dealing with, suppression of \"no info\" tags would be preferred (and I think it's done in some places). It can be noted that Toady has some cases of optional elements in his XML export (there are cases of combined start/end tags with no data where the tag name conveys the info).\n\nNote that this is my opinion, not any kind of \"official\" stand point.\n\nEdit: in the \"circumstance\" case above, the \"no data\" detection logic would need to recurse back to suppress the parent tag pair when nothing within the category has an actual value. I think that case is hand coded, and so could be changed to suppress the useless chatter. When reasonable to do so I'd say it would be good to do that.","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1587917185,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYxOTU3NTk1NQ==","github-url":"https://github.com/DFHack/dfhack/issues/1554#issuecomment-619575955"},"message":"\u003e It's possible for the script to detect that it's dealing with an enum and insert the enum value, but that causes the script to blow up every time it encounters an enum value that hasn't been mapped. It's probably possible to detect that an enum value isn't mapped and insert the numeric value instead, but that's not implemented currently (and ought to be made as a utility function in the script if used, rather than implemented separately in each location).\n\nI'm pretty sure the `df_enums` pseudo-table in exportlegends does this, actually (it prints \"unknown N\" if N is an unknown value instead of breaking). Maybe not all things use it, though.","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1587923694,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYxOTU5NDgwMQ==","github-url":"https://github.com/DFHack/dfhack/issues/1554#issuecomment-619594801"},"message":"The big one, i.e. the default for history event elements, just outputs tostring(v), and I know I reverted at least one case I'd made of using \"naïve\" enum value outputs because of the risk of breaking.\n\nThe general history element case can probably be dealt with by checking if it's an enum, and the case I implemented can be changed to use the wrapper function.\n\nIf ref-target can be reached from Lua it would be possible to write something that suppressed lines containing null values for at least the major ones (by checking if the ref-target value is one in a defined set when the value is -1).","files":null},{"type":3,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1587929555,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYxOTYxMjIzMg==","github-url":"https://github.com/DFHack/dfhack/issues/1554#issuecomment-619612232"},"message":"Exposing ref-target to Lua is a work in progress, hopefully for r2: #1543 \n\nCan you give an example of tostring() breaking? It should work on `nil`, which is what accessing an undefined enum item returns:\n```\n[lua]# ~tostring(df.item_type.FOO)\nnil\n```","files":null},{"type":3,"author":{"id":"df7feee793b3a4f60453609739052ef8e882d092"},"timestamp":1587931034,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYxOTYxNjE0Nw==","github-url":"https://github.com/DFHack/dfhack/issues/1554#issuecomment-619616147"},"message":"I thought ref-target was a work in progress, but not ready yet, so yes, we'll have to wait a little more.\n\ntostring doesn't break, but \"\u003cX\u003e\"..df.item_type [object.X]..\"\u003c/X\u003e\" does, which is what the naïve output tried to do (and I think your example would produce a number on a match, not \"FOO\"?).\n\nThus, my attempt at at an enum output is not directly related to the current default output method of a number, which we'd want to improve to show the enum value instead when applicable (which we can do. I think I'll make an attempt tomorrow to see what happens). Sorry for the confusion created.","files":null},{"type":4,"author":{"id":"e77d0a5f059ed8eaaa1afef6624480d02a2f025a"},"timestamp":1594876614,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MzU1MTQwMDkzNQ=="},"status":2}]}